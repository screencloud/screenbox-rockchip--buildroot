From 7ff1a624114ed7822b0254dfbcfe432e9add855e Mon Sep 17 00:00:00 2001
From: Binyuan Lan <lby@rock-chips.com>
Date: Thu, 23 Mar 2017 17:07:18 +0800
Subject: [PATCH] gstwaylandsink: add dmabuf zero copy

Signed-off-by: Binyuan Lan <lby@rock-chips.com>
---
 ext/wayland/Makefile.am                            |    4 +
 .../fullscreen-shell-unstable-v1-client-protocol.h |  483 ++++++
 ext/wayland/gstwaylandsink.c                       |  780 ++++++++-
 .../linux-dmabuf-unstable-v1-client-protocol.h     |  549 ++++++
 ext/wayland/viewporter-client-protocol.h           |  408 +++++
 ext/wayland/viewporter-protocol.c                  |   64 +
 .../xdg-shell-unstable-v6-client-protocol.h        | 1744 ++++++++++++++++++++
 7 files changed, 4027 insertions(+), 5 deletions(-)
 create mode 100644 ext/wayland/fullscreen-shell-unstable-v1-client-protocol.h
 create mode 100644 ext/wayland/linux-dmabuf-unstable-v1-client-protocol.h
 create mode 100644 ext/wayland/viewporter-client-protocol.h
 create mode 100644 ext/wayland/viewporter-protocol.c
 create mode 100644 ext/wayland/xdg-shell-unstable-v6-client-protocol.h

diff --git a/ext/wayland/Makefile.am b/ext/wayland/Makefile.am
index a23d44d..06fc63e 100644
--- a/ext/wayland/Makefile.am
+++ b/ext/wayland/Makefile.am
@@ -18,6 +18,10 @@ libgstwaylandsink_la_LIBADD = \
 	$(GST_PLUGINS_BASE_LIBS) \
 	-lgstvideo-$(GST_API_VERSION) \
 	-lgstallocators-$(GST_API_VERSION) \
+        -lweston-2 \
+        -lweston-desktop-2 \
+        -ldrm \
+        -L$(top_builddir)/../../target/usr/lib \
 	$(WAYLAND_LIBS) \
 	$(top_builddir)/gst-libs/gst/wayland/libgstwayland-$(GST_API_VERSION).la
 libgstwaylandsink_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
diff --git a/ext/wayland/fullscreen-shell-unstable-v1-client-protocol.h b/ext/wayland/fullscreen-shell-unstable-v1-client-protocol.h
new file mode 100644
index 0000000..b63d7b5
--- /dev/null
+++ b/ext/wayland/fullscreen-shell-unstable-v1-client-protocol.h
@@ -0,0 +1,483 @@
+/* Generated by wayland-scanner 1.13.0 */
+
+#ifndef FULLSCREEN_SHELL_UNSTABLE_V1_CLIENT_PROTOCOL_H
+#define FULLSCREEN_SHELL_UNSTABLE_V1_CLIENT_PROTOCOL_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include "wayland-client.h"
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @page page_fullscreen_shell_unstable_v1 The fullscreen_shell_unstable_v1 protocol
+ * @section page_ifaces_fullscreen_shell_unstable_v1 Interfaces
+ * - @subpage page_iface_zwp_fullscreen_shell_v1 - displays a single surface per output
+ * - @subpage page_iface_zwp_fullscreen_shell_mode_feedback_v1 - 
+ */
+struct wl_output;
+struct wl_surface;
+struct zwp_fullscreen_shell_mode_feedback_v1;
+struct zwp_fullscreen_shell_v1;
+
+/**
+ * @page page_iface_zwp_fullscreen_shell_v1 zwp_fullscreen_shell_v1
+ * @section page_iface_zwp_fullscreen_shell_v1_desc Description
+ *
+ * Displays a single surface per output.
+ *
+ * This interface provides a mechanism for a single client to display
+ * simple full-screen surfaces.  While there technically may be multiple
+ * clients bound to this interface, only one of those clients should be
+ * shown at a time.
+ *
+ * To present a surface, the client uses either the present_surface or
+ * present_surface_for_mode requests.  Presenting a surface takes effect
+ * on the next wl_surface.commit.  See the individual requests for
+ * details about scaling and mode switches.
+ *
+ * The client can have at most one surface per output at any time.
+ * Requesting a surface to be presented on an output that already has a
+ * surface replaces the previously presented surface.  Presenting a null
+ * surface removes its content and effectively disables the output.
+ * Exactly what happens when an output is "disabled" is
+ * compositor-specific.  The same surface may be presented on multiple
+ * outputs simultaneously.
+ *
+ * Once a surface is presented on an output, it stays on that output
+ * until either the client removes it or the compositor destroys the
+ * output.  This way, the client can update the output's contents by
+ * simply attaching a new buffer.
+ *
+ * Warning! The protocol described in this file is experimental and
+ * backward incompatible changes may be made. Backward compatible changes
+ * may be added together with the corresponding interface version bump.
+ * Backward incompatible changes are done by bumping the version number in
+ * the protocol and interface names and resetting the interface version.
+ * Once the protocol is to be declared stable, the 'z' prefix and the
+ * version number in the protocol and interface names are removed and the
+ * interface version number is reset.
+ * @section page_iface_zwp_fullscreen_shell_v1_api API
+ * See @ref iface_zwp_fullscreen_shell_v1.
+ */
+/**
+ * @defgroup iface_zwp_fullscreen_shell_v1 The zwp_fullscreen_shell_v1 interface
+ *
+ * Displays a single surface per output.
+ *
+ * This interface provides a mechanism for a single client to display
+ * simple full-screen surfaces.  While there technically may be multiple
+ * clients bound to this interface, only one of those clients should be
+ * shown at a time.
+ *
+ * To present a surface, the client uses either the present_surface or
+ * present_surface_for_mode requests.  Presenting a surface takes effect
+ * on the next wl_surface.commit.  See the individual requests for
+ * details about scaling and mode switches.
+ *
+ * The client can have at most one surface per output at any time.
+ * Requesting a surface to be presented on an output that already has a
+ * surface replaces the previously presented surface.  Presenting a null
+ * surface removes its content and effectively disables the output.
+ * Exactly what happens when an output is "disabled" is
+ * compositor-specific.  The same surface may be presented on multiple
+ * outputs simultaneously.
+ *
+ * Once a surface is presented on an output, it stays on that output
+ * until either the client removes it or the compositor destroys the
+ * output.  This way, the client can update the output's contents by
+ * simply attaching a new buffer.
+ *
+ * Warning! The protocol described in this file is experimental and
+ * backward incompatible changes may be made. Backward compatible changes
+ * may be added together with the corresponding interface version bump.
+ * Backward incompatible changes are done by bumping the version number in
+ * the protocol and interface names and resetting the interface version.
+ * Once the protocol is to be declared stable, the 'z' prefix and the
+ * version number in the protocol and interface names are removed and the
+ * interface version number is reset.
+ */
+extern const struct wl_interface zwp_fullscreen_shell_v1_interface;
+/**
+ * @page page_iface_zwp_fullscreen_shell_mode_feedback_v1 zwp_fullscreen_shell_mode_feedback_v1
+ * @section page_iface_zwp_fullscreen_shell_mode_feedback_v1_api API
+ * See @ref iface_zwp_fullscreen_shell_mode_feedback_v1.
+ */
+/**
+ * @defgroup iface_zwp_fullscreen_shell_mode_feedback_v1 The zwp_fullscreen_shell_mode_feedback_v1 interface
+ */
+extern const struct wl_interface zwp_fullscreen_shell_mode_feedback_v1_interface;
+
+#ifndef ZWP_FULLSCREEN_SHELL_V1_CAPABILITY_ENUM
+#define ZWP_FULLSCREEN_SHELL_V1_CAPABILITY_ENUM
+/**
+ * @ingroup iface_zwp_fullscreen_shell_v1
+ * capabilities advertised by the compositor
+ *
+ * Various capabilities that can be advertised by the compositor.  They
+ * are advertised one-at-a-time when the wl_fullscreen_shell interface is
+ * bound.  See the wl_fullscreen_shell.capability event for more details.
+ *
+ * ARBITRARY_MODES:
+ * This is a hint to the client that indicates that the compositor is
+ * capable of setting practically any mode on its outputs.  If this
+ * capability is provided, wl_fullscreen_shell.present_surface_for_mode
+ * will almost never fail and clients should feel free to set whatever
+ * mode they like.  If the compositor does not advertise this, it may
+ * still support some modes that are not advertised through wl_global.mode
+ * but it is less likely.
+ *
+ * CURSOR_PLANE:
+ * This is a hint to the client that indicates that the compositor can
+ * handle a cursor surface from the client without actually compositing.
+ * This may be because of a hardware cursor plane or some other mechanism.
+ * If the compositor does not advertise this capability then setting
+ * wl_pointer.cursor may degrade performance or be ignored entirely.  If
+ * CURSOR_PLANE is not advertised, it is recommended that the client draw
+ * its own cursor and set wl_pointer.cursor(NULL).
+ */
+enum zwp_fullscreen_shell_v1_capability {
+	/**
+	 * compositor is capable of almost any output mode
+	 */
+	ZWP_FULLSCREEN_SHELL_V1_CAPABILITY_ARBITRARY_MODES = 1,
+	/**
+	 * compositor has a separate cursor plane
+	 */
+	ZWP_FULLSCREEN_SHELL_V1_CAPABILITY_CURSOR_PLANE = 2,
+};
+#endif /* ZWP_FULLSCREEN_SHELL_V1_CAPABILITY_ENUM */
+
+#ifndef ZWP_FULLSCREEN_SHELL_V1_PRESENT_METHOD_ENUM
+#define ZWP_FULLSCREEN_SHELL_V1_PRESENT_METHOD_ENUM
+/**
+ * @ingroup iface_zwp_fullscreen_shell_v1
+ * different method to set the surface fullscreen
+ *
+ * Hints to indicate to the compositor how to deal with a conflict
+ * between the dimensions of the surface and the dimensions of the
+ * output. The compositor is free to ignore this parameter.
+ */
+enum zwp_fullscreen_shell_v1_present_method {
+	/**
+	 * no preference, apply default policy
+	 */
+	ZWP_FULLSCREEN_SHELL_V1_PRESENT_METHOD_DEFAULT = 0,
+	/**
+	 * center the surface on the output
+	 */
+	ZWP_FULLSCREEN_SHELL_V1_PRESENT_METHOD_CENTER = 1,
+	/**
+	 * scale the surface, preserving aspect ratio, to the largest size that will fit on the output
+	 */
+	ZWP_FULLSCREEN_SHELL_V1_PRESENT_METHOD_ZOOM = 2,
+	/**
+	 * scale the surface, preserving aspect ratio, to fully fill the output cropping if needed
+	 */
+	ZWP_FULLSCREEN_SHELL_V1_PRESENT_METHOD_ZOOM_CROP = 3,
+	/**
+	 * scale the surface to the size of the output ignoring aspect ratio
+	 */
+	ZWP_FULLSCREEN_SHELL_V1_PRESENT_METHOD_STRETCH = 4,
+};
+#endif /* ZWP_FULLSCREEN_SHELL_V1_PRESENT_METHOD_ENUM */
+
+#ifndef ZWP_FULLSCREEN_SHELL_V1_ERROR_ENUM
+#define ZWP_FULLSCREEN_SHELL_V1_ERROR_ENUM
+/**
+ * @ingroup iface_zwp_fullscreen_shell_v1
+ * wl_fullscreen_shell error values
+ *
+ * These errors can be emitted in response to wl_fullscreen_shell requests.
+ */
+enum zwp_fullscreen_shell_v1_error {
+	/**
+	 * present_method is not known
+	 */
+	ZWP_FULLSCREEN_SHELL_V1_ERROR_INVALID_METHOD = 0,
+};
+#endif /* ZWP_FULLSCREEN_SHELL_V1_ERROR_ENUM */
+
+/**
+ * @ingroup iface_zwp_fullscreen_shell_v1
+ * @struct zwp_fullscreen_shell_v1_listener
+ */
+struct zwp_fullscreen_shell_v1_listener {
+	/**
+	 * advertises a capability of the compositor
+	 *
+	 * Advertises a single capability of the compositor.
+	 *
+	 * When the wl_fullscreen_shell interface is bound, this event is
+	 * emitted once for each capability advertised. Valid capabilities
+	 * are given by the wl_fullscreen_shell.capability enum. If clients
+	 * want to take advantage of any of these capabilities, they should
+	 * use a wl_display.sync request immediately after binding to
+	 * ensure that they receive all the capability events.
+	 */
+	void (*capability)(void *data,
+			   struct zwp_fullscreen_shell_v1 *zwp_fullscreen_shell_v1,
+			   uint32_t capability);
+};
+
+/**
+ * @ingroup iface_zwp_fullscreen_shell_v1
+ */
+static inline int
+zwp_fullscreen_shell_v1_add_listener(struct zwp_fullscreen_shell_v1 *zwp_fullscreen_shell_v1,
+				     const struct zwp_fullscreen_shell_v1_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zwp_fullscreen_shell_v1,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZWP_FULLSCREEN_SHELL_V1_RELEASE 0
+#define ZWP_FULLSCREEN_SHELL_V1_PRESENT_SURFACE 1
+#define ZWP_FULLSCREEN_SHELL_V1_PRESENT_SURFACE_FOR_MODE 2
+
+/**
+ * @ingroup iface_zwp_fullscreen_shell_v1
+ */
+#define ZWP_FULLSCREEN_SHELL_V1_CAPABILITY_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zwp_fullscreen_shell_v1
+ */
+#define ZWP_FULLSCREEN_SHELL_V1_RELEASE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_fullscreen_shell_v1
+ */
+#define ZWP_FULLSCREEN_SHELL_V1_PRESENT_SURFACE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_fullscreen_shell_v1
+ */
+#define ZWP_FULLSCREEN_SHELL_V1_PRESENT_SURFACE_FOR_MODE_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_fullscreen_shell_v1 */
+static inline void
+zwp_fullscreen_shell_v1_set_user_data(struct zwp_fullscreen_shell_v1 *zwp_fullscreen_shell_v1, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_fullscreen_shell_v1, user_data);
+}
+
+/** @ingroup iface_zwp_fullscreen_shell_v1 */
+static inline void *
+zwp_fullscreen_shell_v1_get_user_data(struct zwp_fullscreen_shell_v1 *zwp_fullscreen_shell_v1)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_fullscreen_shell_v1);
+}
+
+static inline uint32_t
+zwp_fullscreen_shell_v1_get_version(struct zwp_fullscreen_shell_v1 *zwp_fullscreen_shell_v1)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_fullscreen_shell_v1);
+}
+
+/** @ingroup iface_zwp_fullscreen_shell_v1 */
+static inline void
+zwp_fullscreen_shell_v1_destroy(struct zwp_fullscreen_shell_v1 *zwp_fullscreen_shell_v1)
+{
+	wl_proxy_destroy((struct wl_proxy *) zwp_fullscreen_shell_v1);
+}
+
+/**
+ * @ingroup iface_zwp_fullscreen_shell_v1
+ *
+ * Release the binding from the wl_fullscreen_shell interface.
+ *
+ * This destroys the server-side object and frees this binding.  If
+ * the client binds to wl_fullscreen_shell multiple times, it may wish
+ * to free some of those bindings.
+ */
+static inline void
+zwp_fullscreen_shell_v1_release(struct zwp_fullscreen_shell_v1 *zwp_fullscreen_shell_v1)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_fullscreen_shell_v1,
+			 ZWP_FULLSCREEN_SHELL_V1_RELEASE);
+
+	wl_proxy_destroy((struct wl_proxy *) zwp_fullscreen_shell_v1);
+}
+
+/**
+ * @ingroup iface_zwp_fullscreen_shell_v1
+ *
+ * Present a surface on the given output.
+ *
+ * If the output is null, the compositor will present the surface on
+ * whatever display (or displays) it thinks best.  In particular, this
+ * may replace any or all surfaces currently presented so it should
+ * not be used in combination with placing surfaces on specific
+ * outputs.
+ *
+ * The method parameter is a hint to the compositor for how the surface
+ * is to be presented.  In particular, it tells the compositor how to
+ * handle a size mismatch between the presented surface and the
+ * output.  The compositor is free to ignore this parameter.
+ *
+ * The "zoom", "zoom_crop", and "stretch" methods imply a scaling
+ * operation on the surface.  This will override any kind of output
+ * scaling, so the buffer_scale property of the surface is effectively
+ * ignored.
+ */
+static inline void
+zwp_fullscreen_shell_v1_present_surface(struct zwp_fullscreen_shell_v1 *zwp_fullscreen_shell_v1, struct wl_surface *surface, uint32_t method, struct wl_output *output)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_fullscreen_shell_v1,
+			 ZWP_FULLSCREEN_SHELL_V1_PRESENT_SURFACE, surface, method, output);
+}
+
+/**
+ * @ingroup iface_zwp_fullscreen_shell_v1
+ *
+ * Presents a surface on the given output for a particular mode.
+ *
+ * If the current size of the output differs from that of the surface,
+ * the compositor will attempt to change the size of the output to
+ * match the surface.  The result of the mode-switch operation will be
+ * returned via the provided wl_fullscreen_shell_mode_feedback object.
+ *
+ * If the current output mode matches the one requested or if the
+ * compositor successfully switches the mode to match the surface,
+ * then the mode_successful event will be sent and the output will
+ * contain the contents of the given surface.  If the compositor
+ * cannot match the output size to the surface size, the mode_failed
+ * will be sent and the output will contain the contents of the
+ * previously presented surface (if any).  If another surface is
+ * presented on the given output before either of these has a chance
+ * to happen, the present_cancelled event will be sent.
+ *
+ * Due to race conditions and other issues unknown to the client, no
+ * mode-switch operation is guaranteed to succeed.  However, if the
+ * mode is one advertised by wl_output.mode or if the compositor
+ * advertises the ARBITRARY_MODES capability, then the client should
+ * expect that the mode-switch operation will usually succeed.
+ *
+ * If the size of the presented surface changes, the resulting output
+ * is undefined.  The compositor may attempt to change the output mode
+ * to compensate.  However, there is no guarantee that a suitable mode
+ * will be found and the client has no way to be notified of success
+ * or failure.
+ *
+ * The framerate parameter specifies the desired framerate for the
+ * output in mHz.  The compositor is free to ignore this parameter.  A
+ * value of 0 indicates that the client has no preference.
+ *
+ * If the value of wl_output.scale differs from wl_surface.buffer_scale,
+ * then the compositor may choose a mode that matches either the buffer
+ * size or the surface size.  In either case, the surface will fill the
+ * output.
+ */
+static inline struct zwp_fullscreen_shell_mode_feedback_v1 *
+zwp_fullscreen_shell_v1_present_surface_for_mode(struct zwp_fullscreen_shell_v1 *zwp_fullscreen_shell_v1, struct wl_surface *surface, struct wl_output *output, int32_t framerate)
+{
+	struct wl_proxy *feedback;
+
+	feedback = wl_proxy_marshal_constructor((struct wl_proxy *) zwp_fullscreen_shell_v1,
+			 ZWP_FULLSCREEN_SHELL_V1_PRESENT_SURFACE_FOR_MODE, &zwp_fullscreen_shell_mode_feedback_v1_interface, surface, output, framerate, NULL);
+
+	return (struct zwp_fullscreen_shell_mode_feedback_v1 *) feedback;
+}
+
+/**
+ * @ingroup iface_zwp_fullscreen_shell_mode_feedback_v1
+ * @struct zwp_fullscreen_shell_mode_feedback_v1_listener
+ */
+struct zwp_fullscreen_shell_mode_feedback_v1_listener {
+	/**
+	 * mode switch succeeded
+	 *
+	 * This event indicates that the attempted mode switch operation
+	 * was successful. A surface of the size requested in the mode
+	 * switch will fill the output without scaling.
+	 *
+	 * Upon receiving this event, the client should destroy the
+	 * wl_fullscreen_shell_mode_feedback object.
+	 */
+	void (*mode_successful)(void *data,
+				struct zwp_fullscreen_shell_mode_feedback_v1 *zwp_fullscreen_shell_mode_feedback_v1);
+	/**
+	 * mode switch failed
+	 *
+	 * This event indicates that the attempted mode switch operation
+	 * failed. This may be because the requested output mode is not
+	 * possible or it may mean that the compositor does not want to
+	 * allow it.
+	 *
+	 * Upon receiving this event, the client should destroy the
+	 * wl_fullscreen_shell_mode_feedback object.
+	 */
+	void (*mode_failed)(void *data,
+			    struct zwp_fullscreen_shell_mode_feedback_v1 *zwp_fullscreen_shell_mode_feedback_v1);
+	/**
+	 * mode switch cancelled
+	 *
+	 * This event indicates that the attempted mode switch operation
+	 * was cancelled. Most likely this is because the client requested
+	 * a second mode switch before the first one completed.
+	 *
+	 * Upon receiving this event, the client should destroy the
+	 * wl_fullscreen_shell_mode_feedback object.
+	 */
+	void (*present_cancelled)(void *data,
+				  struct zwp_fullscreen_shell_mode_feedback_v1 *zwp_fullscreen_shell_mode_feedback_v1);
+};
+
+/**
+ * @ingroup iface_zwp_fullscreen_shell_mode_feedback_v1
+ */
+static inline int
+zwp_fullscreen_shell_mode_feedback_v1_add_listener(struct zwp_fullscreen_shell_mode_feedback_v1 *zwp_fullscreen_shell_mode_feedback_v1,
+						   const struct zwp_fullscreen_shell_mode_feedback_v1_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zwp_fullscreen_shell_mode_feedback_v1,
+				     (void (**)(void)) listener, data);
+}
+
+/**
+ * @ingroup iface_zwp_fullscreen_shell_mode_feedback_v1
+ */
+#define ZWP_FULLSCREEN_SHELL_MODE_FEEDBACK_V1_MODE_SUCCESSFUL_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_fullscreen_shell_mode_feedback_v1
+ */
+#define ZWP_FULLSCREEN_SHELL_MODE_FEEDBACK_V1_MODE_FAILED_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_fullscreen_shell_mode_feedback_v1
+ */
+#define ZWP_FULLSCREEN_SHELL_MODE_FEEDBACK_V1_PRESENT_CANCELLED_SINCE_VERSION 1
+
+
+/** @ingroup iface_zwp_fullscreen_shell_mode_feedback_v1 */
+static inline void
+zwp_fullscreen_shell_mode_feedback_v1_set_user_data(struct zwp_fullscreen_shell_mode_feedback_v1 *zwp_fullscreen_shell_mode_feedback_v1, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_fullscreen_shell_mode_feedback_v1, user_data);
+}
+
+/** @ingroup iface_zwp_fullscreen_shell_mode_feedback_v1 */
+static inline void *
+zwp_fullscreen_shell_mode_feedback_v1_get_user_data(struct zwp_fullscreen_shell_mode_feedback_v1 *zwp_fullscreen_shell_mode_feedback_v1)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_fullscreen_shell_mode_feedback_v1);
+}
+
+static inline uint32_t
+zwp_fullscreen_shell_mode_feedback_v1_get_version(struct zwp_fullscreen_shell_mode_feedback_v1 *zwp_fullscreen_shell_mode_feedback_v1)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_fullscreen_shell_mode_feedback_v1);
+}
+
+/** @ingroup iface_zwp_fullscreen_shell_mode_feedback_v1 */
+static inline void
+zwp_fullscreen_shell_mode_feedback_v1_destroy(struct zwp_fullscreen_shell_mode_feedback_v1 *zwp_fullscreen_shell_mode_feedback_v1)
+{
+	wl_proxy_destroy((struct wl_proxy *) zwp_fullscreen_shell_mode_feedback_v1);
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/ext/wayland/gstwaylandsink.c b/ext/wayland/gstwaylandsink.c
index 4b39ae1..b1123bd 100644
--- a/ext/wayland/gstwaylandsink.c
+++ b/ext/wayland/gstwaylandsink.c
@@ -49,6 +49,643 @@
 #include <gst/wayland/wayland.h>
 #include <gst/video/videooverlay.h>
 
+
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+#include <assert.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <signal.h>
+#include <fcntl.h>
+
+#include <libdrm/drm.h>
+#include <libdrm/drm_fourcc.h>
+
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <linux/input.h>
+#include <sys/time.h>
+
+#include <wayland-client.h>
+#include "xdg-shell-unstable-v6-client-protocol.h"
+#include "fullscreen-shell-unstable-v1-client-protocol.h"
+#include "linux-dmabuf-unstable-v1-client-protocol.h"
+#include "viewporter-client-protocol.h"
+
+#define CLEAR(x) memset(&(x), 0, sizeof(x))
+#define DRM_FORMAT_NV12_10	fourcc_code('N', 'A', '1', '2')
+
+static void
+redraw(void *data, struct wl_callback *callback, uint32_t time);
+
+static uint32_t
+parse_format(const char fmt[4])
+{
+	return fourcc_code(fmt[0], fmt[1], fmt[2], fmt[3]);
+}
+
+static inline const char *
+dump_format(uint32_t format, char out[4])
+{
+#if BYTE_ORDER == BIG_ENDIAN
+	format = __builtin_bswap32(format);
+#endif
+	memcpy(out, &format, 4);
+	return out;
+}
+
+struct buffer_format {
+	int width;
+	int height;
+	uint32_t format;
+
+	unsigned num_planes;
+	unsigned strides[4];
+};
+
+struct display {
+	struct wl_display *display;
+	struct wl_registry *registry;
+	struct wp_viewporter *viewporter;
+	struct wl_compositor *compositor;
+	struct wl_seat *seat;
+	struct wl_keyboard *keyboard;
+	struct zxdg_shell_v6 *shell;
+	struct zwp_fullscreen_shell_v1 *fshell;
+	struct zwp_linux_dmabuf_v1 *dmabuf;
+	bool requested_format_found;
+
+	struct buffer_format format;
+	uint32_t drm_format;
+
+	unsigned int display_width;
+	unsigned int display_height;
+	int drm_fd;
+};
+
+struct drm_bo {
+	unsigned int width;
+	unsigned int height;
+	unsigned int pitch;
+	uint32_t format;
+	size_t size;
+
+	uint32_t handle;
+	int prime_fd;
+
+	void *ptr;
+};
+
+struct buffer {
+	struct wl_buffer *buffer;
+	struct display *display;
+	struct drm_bo *bo;
+	int busy;
+	int index;
+
+	int dmabuf_fds[4];
+	int data_offsets[4];
+};
+
+#define NUM_BUFFERS 1
+
+struct window {
+	struct display *display;
+	struct wl_surface *surface;
+	struct zxdg_surface_v6 *xdg_surface;
+	struct zxdg_toplevel_v6 *xdg_toplevel;
+	struct buffer buffers[NUM_BUFFERS];
+	struct wl_callback *callback;
+	struct wp_viewport *viewport;
+	bool wait_for_configure;
+	bool initialized;
+};
+
+static bool debug_enable = false;
+static bool running = true;
+static struct display *display;
+static struct window *window;
+static int fd;
+static struct drm_bo *drm_bo;
+
+
+void showfps()
+{
+	static int mFrameCount;
+	static int mLastFrameCount = 0;
+	static struct timeval last;
+	static long mLastFpsTime = 0;
+	static float mFps = 0;
+	long diff;
+	struct timeval now;
+
+	if (mFrameCount == 0)
+		gettimeofday(&last, NULL);
+	gettimeofday(&now, NULL);
+	mFrameCount++;
+	diff = (now.tv_sec - last.tv_sec) * 1000000 + now.tv_usec - last.tv_usec;
+	if (diff > 500000) {
+		mFps =  ((mFrameCount - mLastFrameCount) * 1.0) * 1000000 / diff;
+		last = now;
+		mLastFrameCount = mFrameCount;
+		if (debug_enable)
+			fprintf(stderr, "Fps = %2.3f mFrameConut=%d now=%d\n", mFps, mFrameCount, now.tv_sec * 1000000 + now.tv_usec);
+	}
+}
+
+static int
+queue(struct display *display, struct buffer *buffer)
+{
+	return 1;
+}
+
+static void
+buffer_release(void *data, struct wl_buffer *buffer)
+{
+	struct buffer *mybuf = data;
+
+	mybuf->busy = 0;
+	wl_buffer_destroy(buffer);
+
+	if (!queue(mybuf->display, mybuf))
+		running = false;
+}
+
+static const struct wl_buffer_listener buffer_listener = {
+	buffer_release
+};
+
+static unsigned int
+set_format(struct display *display, uint32_t format)
+{
+	return 1;
+}
+
+static void
+create_succeeded(void *data,
+		 struct zwp_linux_buffer_params_v1 *params,
+		 struct wl_buffer *new_buffer)
+{
+	struct buffer *buffer = data;
+
+	if (debug_enable)
+    	fprintf(stderr,"gstwaylandsink: create success----------\n");
+	buffer->buffer = new_buffer;
+	wl_buffer_add_listener(buffer->buffer, &buffer_listener, buffer);
+
+	zwp_linux_buffer_params_v1_destroy(params);
+}
+
+static void
+create_failed(void *data, struct zwp_linux_buffer_params_v1 *params)
+{
+	struct buffer *buffer = data;
+	unsigned i;
+   
+	buffer->buffer = NULL;
+
+	zwp_linux_buffer_params_v1_destroy(params);
+
+	for (i = 0; i < buffer->display->format.num_planes; ++i){
+		fprintf(stderr,"gstwaylandsink: create failed close fd %d\n",buffer->dmabuf_fds[i]);
+		close(buffer->dmabuf_fds[i]);
+	}
+	running = false;
+
+	fprintf(stderr, "gstwaylandsink: Error: zwp_linux_buffer_params.create failed.\n");
+}
+
+static const struct zwp_linux_buffer_params_v1_listener params_listener = {
+	create_succeeded,
+	create_failed
+};
+
+static void
+create_dmabuf_buffer(struct display *display, struct buffer *buffer)
+{
+	struct zwp_linux_buffer_params_v1 *params;
+	uint64_t modifier;
+	uint32_t flags;
+	unsigned i;
+	
+	if (debug_enable)
+		fprintf(stderr,"gstwaylandsink: create_dmabuf_buffer \n");
+
+	modifier = 0;
+	flags = 0;
+
+	/* XXX: apparently some webcams may actually provide y-inverted images,
+	 * in which case we should set
+	 * flags = ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_Y_INVERT
+	 */
+	params = zwp_linux_dmabuf_v1_create_params(display->dmabuf);
+	for (i = 0; i < display->format.num_planes; ++i)
+		zwp_linux_buffer_params_v1_add(params,
+		                               buffer->dmabuf_fds[i],
+		                               i, /* plane_idx */
+		                               buffer->data_offsets[i], /* offset */
+		                               display->format.strides[i],
+		                               modifier >> 32,
+		                               modifier & 0xffffffff);
+	zwp_linux_buffer_params_v1_add_listener(params, &params_listener,
+	                                        buffer);
+	zwp_linux_buffer_params_v1_create(params,
+	                                  display->format.width,
+	                                  display->format.height,
+	                                  display->drm_format,
+	                                  flags);
+}
+
+static int
+dequeue(struct display *display)
+{
+	static int index;
+
+	index++;
+	index = index % NUM_BUFFERS;
+
+	return index;
+}
+
+static void
+xdg_surface_handle_configure(void *data, struct zxdg_surface_v6 *surface,
+			     uint32_t serial)
+{
+	struct window *window = data;
+
+	zxdg_surface_v6_ack_configure(surface, serial);
+
+	if (window->initialized && window->wait_for_configure){
+		fprintf(stderr,"gstwaylandsink: xdg_surface_handle_configure\n");
+		redraw(window, NULL, 0);
+		}
+	
+	window->wait_for_configure = false;
+}
+
+static const struct zxdg_surface_v6_listener xdg_surface_listener = {
+	xdg_surface_handle_configure,
+};
+
+static void
+xdg_toplevel_handle_configure(void *data, struct zxdg_toplevel_v6 *toplevel,
+			      int32_t width, int32_t height,
+			      struct wl_array *states)
+{
+}
+
+static void
+xdg_toplevel_handle_close(void *data, struct zxdg_toplevel_v6 *xdg_toplevel)
+{
+	running = 0;
+}
+
+static const struct zxdg_toplevel_v6_listener xdg_toplevel_listener = {
+	xdg_toplevel_handle_configure,
+	xdg_toplevel_handle_close,
+};
+
+static struct window *
+create_window(struct display *display)
+{
+	struct window *window;
+
+	window = malloc(sizeof *window);
+	if (!window)
+		return NULL;
+	memset(window, 0, sizeof *window);
+
+	window->callback = NULL;
+	window->display = display;
+	window->surface = wl_compositor_create_surface(display->compositor);
+	window->viewport = wp_viewporter_get_viewport(display->viewporter,
+						      window->surface);
+	if (display->shell) {
+		window->xdg_surface =
+			zxdg_shell_v6_get_xdg_surface(display->shell,
+						      window->surface);
+
+		assert(window->xdg_surface);
+
+		zxdg_surface_v6_add_listener(window->xdg_surface,
+					     &xdg_surface_listener, window);
+
+		window->xdg_toplevel =
+			zxdg_surface_v6_get_toplevel(window->xdg_surface);
+
+		assert(window->xdg_toplevel);
+
+		zxdg_toplevel_v6_add_listener(window->xdg_toplevel,
+					      &xdg_toplevel_listener, window);
+
+		zxdg_toplevel_v6_set_title(window->xdg_toplevel, "simple-dmabuf-v4l");
+
+		window->wait_for_configure = true;
+		wl_surface_commit(window->surface);
+	} else if (display->fshell) {
+		zwp_fullscreen_shell_v1_present_surface(display->fshell,
+		                                        window->surface,
+		                                        ZWP_FULLSCREEN_SHELL_V1_PRESENT_METHOD_DEFAULT,
+		                                        NULL);
+	} else {
+		assert(0);
+	}
+
+	return window;
+}
+
+static void
+destroy_window(struct window *window)
+{
+	int i;
+	unsigned j;
+
+	if (window->callback)
+		wl_callback_destroy(window->callback);
+
+	if (window->xdg_toplevel)
+		zxdg_toplevel_v6_destroy(window->xdg_toplevel);
+	if (window->xdg_surface)
+		zxdg_surface_v6_destroy(window->xdg_surface);
+	if (window->viewport)
+		wp_viewport_destroy(window->viewport);
+	wl_surface_destroy(window->surface);
+
+	for (i = 0; i < NUM_BUFFERS; i++) {
+		if (!window->buffers[i].buffer)
+			continue;
+
+		wl_buffer_destroy(window->buffers[i].buffer);
+		for (j = 0; j < window->display->format.num_planes; ++j)
+			close(window->buffers[i].dmabuf_fds[j]);
+	}
+
+	free(window);
+}
+
+static const struct wl_callback_listener frame_listener;
+
+static void
+redraw(void *data, struct wl_callback *callback, uint32_t time)
+{
+	struct window *window = data;
+	struct buffer *buffer;
+	int index, num_busy = 0;
+
+#if 0
+	/* Check for a deadlock situation where we would block forever trying
+	 * to dequeue a buffer while all of them are locked by the compositor.
+	 */
+	for (index = 0; index < NUM_BUFFERS; ++index)
+		if (window->buffers[index].busy)
+			++num_busy;
+
+	/* A robust application would just postpone redraw until it has queued
+	 * a buffer.
+	 */
+	assert(num_busy < NUM_BUFFERS);
+#endif
+	if (debug_enable)
+    	fprintf(stderr,"gstwaylandsink: redraw---------------\n");
+	index = dequeue(window->display);
+	if (index < 0) {	
+		/* We couldn’t get any buffer out of the camera, exiting. */
+		fprintf(stderr,"index < 0, return");
+		running = false;
+		return;
+	}
+
+	buffer = &window->buffers[index];
+	wl_surface_attach(window->surface, buffer->buffer, 0, 0);
+	wl_surface_damage(window->surface, 0, 0,
+	                  window->display->format.width,
+	                  window->display->format.height);
+
+	if (callback)
+		wl_callback_destroy(callback);
+
+	window->callback = wl_surface_frame(window->surface);
+	wl_callback_add_listener(window->callback, &frame_listener, window);
+	wl_surface_commit(window->surface);
+	showfps();
+	buffer->busy = 1;
+	
+}
+
+static const struct wl_callback_listener frame_listener = {
+	redraw
+};
+
+static void
+dmabuf_format(void *data, struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf,
+              uint32_t format)
+{
+	struct display *d = data;
+
+	if (format == d->drm_format)
+		d->requested_format_found = true;
+}
+
+static const struct zwp_linux_dmabuf_v1_listener dmabuf_listener = {
+	dmabuf_format
+};
+
+static void
+keyboard_handle_keymap(void *data, struct wl_keyboard *keyboard,
+                       uint32_t format, int fd, uint32_t size)
+{
+	/* Just so we don’t leak the keymap fd */
+	close(fd);
+}
+
+static void
+keyboard_handle_enter(void *data, struct wl_keyboard *keyboard,
+                      uint32_t serial, struct wl_surface *surface,
+                      struct wl_array *keys)
+{
+}
+
+static void
+keyboard_handle_leave(void *data, struct wl_keyboard *keyboard,
+                      uint32_t serial, struct wl_surface *surface)
+{
+}
+
+static void
+keyboard_handle_key(void *data, struct wl_keyboard *keyboard,
+                    uint32_t serial, uint32_t time, uint32_t key,
+                    uint32_t state)
+{
+	struct display *d = data;
+
+	if (!d->shell)
+		return;
+
+	if (key == KEY_ESC && state)
+		running = false;
+}
+
+static void
+keyboard_handle_modifiers(void *data, struct wl_keyboard *keyboard,
+                          uint32_t serial, uint32_t mods_depressed,
+                          uint32_t mods_latched, uint32_t mods_locked,
+                          uint32_t group)
+{
+}
+
+static const struct wl_keyboard_listener keyboard_listener = {
+	keyboard_handle_keymap,
+	keyboard_handle_enter,
+	keyboard_handle_leave,
+	keyboard_handle_key,
+	keyboard_handle_modifiers,
+};
+
+static void
+seat_handle_capabilities(void *data, struct wl_seat *seat,
+                         enum wl_seat_capability caps)
+{
+	struct display *d = data;
+
+	if ((caps & WL_SEAT_CAPABILITY_KEYBOARD) && !d->keyboard) {
+		d->keyboard = wl_seat_get_keyboard(seat);
+		wl_keyboard_add_listener(d->keyboard, &keyboard_listener, d);
+	} else if (!(caps & WL_SEAT_CAPABILITY_KEYBOARD) && d->keyboard) {
+		wl_keyboard_destroy(d->keyboard);
+		d->keyboard = NULL;
+	}
+}
+
+static const struct wl_seat_listener seat_listener = {
+	seat_handle_capabilities,
+};
+
+static void
+xdg_shell_ping(void *data, struct zxdg_shell_v6 *shell, uint32_t serial)
+{
+	zxdg_shell_v6_pong(shell, serial);
+}
+
+static const struct zxdg_shell_v6_listener xdg_shell_listener = {
+	xdg_shell_ping,
+};
+
+static void
+registry_handle_global(void *data, struct wl_registry *registry,
+                       uint32_t id, const char *interface, uint32_t version)
+{
+	struct display *d = data;
+
+	if (strcmp(interface, "wl_compositor") == 0) {
+		d->compositor =
+			wl_registry_bind(registry,
+			                 id, &wl_compositor_interface, version);
+	} else if (strcmp(interface, "wp_viewporter") == 0) {
+		d->viewporter = wl_registry_bind(registry, id,
+						 &wp_viewporter_interface, 1);
+	} else if (strcmp(interface, "wl_seat") == 0) {
+		d->seat = wl_registry_bind(registry,
+		                           id, &wl_seat_interface, 1);
+		wl_seat_add_listener(d->seat, &seat_listener, d);
+	} else if (strcmp(interface, "zxdg_shell_v6") == 0) {
+		d->shell = wl_registry_bind(registry,
+		                            id, &zxdg_shell_v6_interface, 1);
+		zxdg_shell_v6_add_listener(d->shell, &xdg_shell_listener, d);
+#if 0
+	} else if (strcmp(interface, "zwp_fullscreen_shell_v1") == 0) {
+		d->fshell = wl_registry_bind(registry,
+		                             id, &zwp_fullscreen_shell_v1_interface,
+		                             1);
+#endif
+	} else if (strcmp(interface, "zwp_linux_dmabuf_v1") == 0) {
+		d->dmabuf = wl_registry_bind(registry,
+		                             id, &zwp_linux_dmabuf_v1_interface,
+		                             1);
+		zwp_linux_dmabuf_v1_add_listener(d->dmabuf, &dmabuf_listener,
+		                                 d);
+	}
+}
+
+static void
+registry_handle_global_remove(void *data, struct wl_registry *registry,
+                              uint32_t name)
+{
+}
+
+static const struct wl_registry_listener registry_listener = {
+	registry_handle_global,
+	registry_handle_global_remove
+};
+
+static struct display *
+create_display(uint32_t requested_format)
+{
+	struct display *display;
+
+	display = malloc(sizeof *display);
+	if (display == NULL) {
+		fprintf(stderr, "out of memory\n");
+		exit(1);
+	}
+	display->display = wl_display_connect(NULL);
+	assert(display->display);
+
+	display->drm_format = requested_format;
+
+	display->registry = wl_display_get_registry(display->display);
+	wl_registry_add_listener(display->registry,
+	                         &registry_listener, display);
+	wl_display_roundtrip(display->display);
+	if (display->dmabuf == NULL) {
+		fprintf(stderr, "No zwp_linux_dmabuf global\n");
+		exit(1);
+	}
+
+	wl_display_roundtrip(display->display);
+
+	/* XXX: fake, because the compositor does not yet advertise anything */
+	display->requested_format_found = true;
+
+	if (!display->requested_format_found) {
+		fprintf(stderr, "DRM_FORMAT_YUYV not available\n");
+		exit(1);
+	}
+
+	return display;
+}
+
+static void
+destroy_display(struct display *display)
+{
+	if (display->dmabuf)
+		zwp_linux_dmabuf_v1_destroy(display->dmabuf);
+
+	if (display->shell)
+		zxdg_shell_v6_destroy(display->shell);
+
+	if (display->fshell)
+		zwp_fullscreen_shell_v1_release(display->fshell);
+
+	if (display->compositor)
+		wl_compositor_destroy(display->compositor);
+
+	wl_registry_destroy(display->registry);
+	wl_display_flush(display->display);
+	wl_display_disconnect(display->display);
+	free(display);
+}
+
+static void
+signal_int(int signum)
+{
+	running = false;
+}
+
 /* signals */
 enum
 {
@@ -72,7 +709,7 @@ static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
     GST_STATIC_CAPS (GST_VIDEO_CAPS_MAKE
         ("{ BGRx, BGRA, RGBx, xBGR, xRGB, RGBA, ABGR, ARGB, RGB, BGR, "
             "RGB16, BGR16, YUY2, YVYU, UYVY, AYUV, NV12, NV21, NV16, "
-            "YUV9, YVU9, Y41B, I420, YV12, Y42B, v308 }"))
+            "YUV9, YVU9, Y41B, I420, YV12, Y42B, v308,P010_10LE,NV12_10 }"))
     );
 
 static void gst_wayland_sink_get_property (GObject * object,
@@ -158,6 +795,18 @@ gst_wayland_sink_class_init (GstWaylandSinkClass * klass)
       g_param_spec_string ("display", "Wayland Display name", "Wayland "
           "display name to connect to, if not supplied via the GstContext",
           NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+	struct sigaction sigint;
+	sigint.sa_handler = signal_int;
+	sigemptyset(&sigint.sa_mask);
+	sigint.sa_flags = SA_RESETHAND;
+	sigaction(SIGINT, &sigint, NULL);
+		const char *debug;
+
+	debug = getenv("GSTWAYLANDSINKDEBUG");
+	if (debug && (strstr(debug, "enable") || strstr(debug, "1")))
+		debug_enable = true;
+
 }
 
 static void
@@ -403,9 +1052,12 @@ gst_wayland_sink_get_caps (GstBaseSink * bsink, GstCaps * filter)
       g_value_init (&value, G_TYPE_STRING);
       fmt = g_array_index (formats, uint32_t, i);
       g_value_set_static_string (&value, gst_wl_shm_format_to_string (fmt));
+	  GST_DEBUG_OBJECT (sink, "format-----------: %s" ,gst_wl_shm_format_to_string (fmt));
       gst_value_list_append_and_take_value (&list, &value);
     }
-
+	g_value_init (&value, G_TYPE_STRING);
+	g_value_set_static_string(&value,"P010_10LE");
+    gst_value_list_append_and_take_value(&list,&value);
     caps = gst_caps_make_writable (caps);
     gst_structure_take_value (gst_caps_get_structure (caps, 0), "format",
         &list);
@@ -467,6 +1119,7 @@ gst_wayland_sink_set_caps (GstBaseSink * bsink, GstCaps * caps)
   if (!gst_video_info_from_caps (&info, caps))
     goto invalid_format;
 
+#if 0
   format = gst_video_format_to_wl_shm_format (GST_VIDEO_INFO_FORMAT (&info));
   if ((gint) format == -1)
     goto invalid_format;
@@ -480,6 +1133,7 @@ gst_wayland_sink_set_caps (GstBaseSink * bsink, GstCaps * caps)
 
   if (i >= formats->len)
     goto unsupported_format;
+#endif
 
   /* store the video info */
   sink->video_info = info;
@@ -494,6 +1148,29 @@ gst_wayland_sink_set_caps (GstBaseSink * bsink, GstCaps * caps)
   gst_object_replace ((GstObject **) & sink->pool, (GstObject *) newpool);
   gst_object_unref (newpool);
 
+  uint32_t drm_format;
+  GstVideoFormat fmt;
+  fmt = (GST_VIDEO_INFO_FORMAT (&info));
+  if(fmt==GST_VIDEO_FORMAT_P010_10LE){
+  	fprintf(stderr,"p010------width=%d,height=%d\n",GST_VIDEO_INFO_WIDTH (&info),GST_VIDEO_INFO_HEIGHT (&info));
+	drm_format = DRM_FORMAT_NV12_10;
+  }else{
+       drm_format = parse_format("NV12");
+  }
+  display = create_display(drm_format);
+  display->format.format = drm_format;
+  display->format.num_planes = 2;
+  display->format.width =GST_VIDEO_INFO_WIDTH (&info);
+  display->format.height =GST_VIDEO_INFO_HEIGHT (&info);
+	  
+  display->drm_fd = open("/dev/dri/card0", O_RDWR);
+  if (display->drm_fd < 0) {
+		  fprintf(stderr, "failed to open /dev/dri/card0\n");
+		  //return 1;
+  }
+  
+  window = create_window(display);
+
   return TRUE;
 
 invalid_format:
@@ -501,6 +1178,7 @@ invalid_format:
     GST_ERROR_OBJECT (sink,
         "Could not locate image format from caps %" GST_PTR_FORMAT, caps);
     return FALSE;
+    
   }
 unsupported_format:
   {
@@ -557,6 +1235,76 @@ static const struct wl_callback_listener frame_callback_listener = {
   frame_redraw_callback
 };
 
+
+static gboolean 
+gst_wayland_sink_put(GstWaylandSink * wlsink, GstBuffer * sink_buffer) {
+    GstMemory *mem;
+	guint32 w, h, fmt;
+	int lcd_w,lcd_h, scale_w, scale_h;
+	guint32 dmabuf_fd;
+	gint index;
+	gint ret = 0;
+
+	mem = gst_buffer_peek_memory (sink_buffer, 0);
+	
+	dmabuf_fd = gst_dmabuf_memory_get_fd(mem);
+	
+	w = GST_VIDEO_INFO_WIDTH (&wlsink->video_info);
+	h = GST_VIDEO_INFO_HEIGHT (&wlsink->video_info);
+	
+	if (debug_enable)
+		fprintf(stderr,"gstwaylandsink: dmabuf_fd=%d, w=%d, h=%d \n",dmabuf_fd,w,h);
+
+	for (index = 0; index < NUM_BUFFERS; ++index) {
+		struct buffer *buffer;
+		GstMapInfo info;
+
+		buffer = &window->buffers[index];
+		buffer->display = display;
+		buffer->index = index;
+
+        GstVideoMeta *video_info;
+        video_info = gst_buffer_get_video_meta (sink_buffer);
+		if (display->format.width >= 3840) {
+	        display->format.strides[0] = video_info->stride[0]*2;
+		    display->format.strides[1] = video_info->stride[1]*2;
+			display->format.height = h/2;
+		} else {
+			display->format.strides[0] = video_info->stride[0];
+			display->format.strides[1] = video_info->stride[1];
+		}
+		
+		buffer->data_offsets[0] = video_info->offset[0];
+		buffer->data_offsets[1] = video_info->offset[1];
+		
+		buffer->dmabuf_fds[0] = dmabuf_fd;
+		buffer->dmabuf_fds[1] = dmabuf_fd;
+
+		create_dmabuf_buffer(display, buffer);
+	}
+
+	window->initialized = true;
+	
+/*** screen size need*** to do *****/
+    lcd_h = 2048;
+	lcd_w = 1536;
+
+	scale_w = lcd_w;
+	scale_h = h * scale_w / w;
+
+	
+	//wl_surface_set_buffer_transform(window->surface, WL_OUTPUT_TRANSFORM_NORMAL);
+	wp_viewport_set_destination(window->viewport, scale_w, scale_h);
+	if (display->format.format == DRM_FORMAT_NV12_10)
+		wp_viewport_set_destination(window->viewport, 1536, 1200);
+	
+	wl_display_roundtrip(display->display);
+
+	ret = wl_display_dispatch(display->display);
+
+	return 0;	
+}
+
 /* must be called with the render lock */
 static void
 render_last_buffer (GstWaylandSink * sink)
@@ -577,9 +1325,14 @@ render_last_buffer (GstWaylandSink * sink)
     info = &sink->video_info;
     sink->video_info_changed = FALSE;
   }
+  //gst_buffer_ref(sink->last_buffer);
+  //gst_wayland_sink_put(sink, sink->last_buffer);
+  //gst_buffer_unref(sink->last_buffer);
   gst_wl_window_render (sink->window, wlbuffer, info);
 }
 
+
+
 static GstFlowReturn
 gst_wayland_sink_show_frame (GstVideoSink * vsink, GstBuffer * buffer)
 {
@@ -600,6 +1353,7 @@ gst_wayland_sink_show_frame (GstVideoSink * vsink, GstBuffer * buffer)
     g_mutex_lock (&sink->render_lock);
 
     if (!sink->window) {
+		printf(stderr,"sink-> false");
       /* if we were not provided a window, create one ourselves */
       sink->window = gst_wl_window_new_toplevel (sink->display,
           &sink->video_info, &sink->render_lock);
@@ -613,7 +1367,16 @@ gst_wayland_sink_show_frame (GstVideoSink * vsink, GstBuffer * buffer)
   /* make sure that the application has called set_render_rectangle() */
   if (G_UNLIKELY (sink->window->render_rectangle.w == 0))
     goto no_window_size;
-
+  GstMemory *mem;
+  mem = gst_buffer_peek_memory (buffer, 0);
+  gst_buffer_ref(buffer);
+  if (gst_is_dmabuf_memory(mem)) {
+        gst_wayland_sink_put(sink, buffer);
+		gst_buffer_unref(buffer);
+		//sink->redraw_pending = TRUE;
+        GST_DEBUG_OBJECT(sink, "buffer is dmabuffer");
+	}
+  goto done;
   wlbuffer = gst_buffer_get_wl_buffer (buffer);
 
   if (G_LIKELY (wlbuffer && wlbuffer->display == sink->display)) {
@@ -641,7 +1404,15 @@ gst_wayland_sink_show_frame (GstVideoSink * vsink, GstBuffer * buffer)
 
     /* FIXME check all memory when introducing DMA-Buf */
     mem = gst_buffer_peek_memory (buffer, 0);
-
+    /*
+	if (gst_is_dmabuf_memory(mem)) {
+        gst_wayland_sink_put(sink, buffer);
+        GST_DEBUG_OBJECT(sink, "buffer is dmabuffer");
+	}
+    //gst_buffer_unref (buffer);
+	goto no_buffer;
+	*/
+	
     if (gst_is_wl_shm_memory (mem)) {
       wbuf = gst_wl_shm_memory_construct_wl_buffer (mem, sink->display,
           &sink->video_info);
@@ -719,7 +1490,6 @@ gst_wayland_sink_show_frame (GstVideoSink * vsink, GstBuffer * buffer)
 
   gst_buffer_replace (&sink->last_buffer, to_render);
   render_last_buffer (sink);
-
   if (buffer != to_render)
     gst_buffer_unref (to_render);
   goto done;
diff --git a/ext/wayland/linux-dmabuf-unstable-v1-client-protocol.h b/ext/wayland/linux-dmabuf-unstable-v1-client-protocol.h
new file mode 100644
index 0000000..1e8b915
--- /dev/null
+++ b/ext/wayland/linux-dmabuf-unstable-v1-client-protocol.h
@@ -0,0 +1,549 @@
+/* Generated by wayland-scanner 1.13.0 */
+
+#ifndef LINUX_DMABUF_UNSTABLE_V1_CLIENT_PROTOCOL_H
+#define LINUX_DMABUF_UNSTABLE_V1_CLIENT_PROTOCOL_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include "wayland-client.h"
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @page page_linux_dmabuf_unstable_v1 The linux_dmabuf_unstable_v1 protocol
+ * @section page_ifaces_linux_dmabuf_unstable_v1 Interfaces
+ * - @subpage page_iface_zwp_linux_dmabuf_v1 - factory for creating dmabuf-based wl_buffers
+ * - @subpage page_iface_zwp_linux_buffer_params_v1 - parameters for creating a dmabuf-based wl_buffer
+ * @section page_copyright_linux_dmabuf_unstable_v1 Copyright
+ * <pre>
+ *
+ * Copyright Â© 2014, 2015 Collabora, Ltd.
+ *
+ * Permission to use, copy, modify, distribute, and sell this
+ * software and its documentation for any purpose is hereby granted
+ * without fee, provided that the above copyright notice appear in
+ * all copies and that both that copyright notice and this permission
+ * notice appear in supporting documentation, and that the name of
+ * the copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+ * THIS SOFTWARE.
+ * </pre>
+ */
+struct wl_buffer;
+struct zwp_linux_buffer_params_v1;
+struct zwp_linux_dmabuf_v1;
+
+/**
+ * @page page_iface_zwp_linux_dmabuf_v1 zwp_linux_dmabuf_v1
+ * @section page_iface_zwp_linux_dmabuf_v1_desc Description
+ *
+ * Following the interfaces from:
+ * https://www.khronos.org/registry/egl/extensions/EXT/EGL_EXT_image_dma_buf_import.txt
+ * and the Linux DRM sub-system's AddFb2 ioctl.
+ *
+ * This interface offers a way to create generic dmabuf-based
+ * wl_buffers. Immediately after a client binds to this interface,
+ * the set of supported formats is sent with 'format' events.
+ *
+ * The following are required from clients:
+ *
+ * - Clients must ensure that either all data in the dma-buf is
+ * coherent for all subsequent read access or that coherency is
+ * correctly handled by the underlying kernel-side dma-buf
+ * implementation.
+ *
+ * - Don't make any more attachments after sending the buffer to the
+ * compositor. Making more attachments later increases the risk of
+ * the compositor not being able to use (re-import) an existing
+ * dmabuf-based wl_buffer.
+ *
+ * The underlying graphics stack must ensure the following:
+ *
+ * - The dmabuf file descriptors relayed to the server will stay valid
+ * for the whole lifetime of the wl_buffer. This means the server may
+ * at any time use those fds to import the dmabuf into any kernel
+ * sub-system that might accept it.
+ *
+ * To create a wl_buffer from one or more dmabufs, a client creates a
+ * zwp_linux_dmabuf_params_v1 object with a zwp_linux_dmabuf_v1.create_params
+ * request. All planes required by the intended format are added with
+ * the 'add' request. Finally, a 'create' request is issued. The server
+ * will reply with either a 'created' event which provides the final
+ * wl_buffer or a 'failed' event saying that it cannot use the dmabufs
+ * provided.
+ *
+ * Warning! The protocol described in this file is experimental and
+ * backward incompatible changes may be made. Backward compatible changes
+ * may be added together with the corresponding interface version bump.
+ * Backward incompatible changes are done by bumping the version number in
+ * the protocol and interface names and resetting the interface version.
+ * Once the protocol is to be declared stable, the 'z' prefix and the
+ * version number in the protocol and interface names are removed and the
+ * interface version number is reset.
+ * @section page_iface_zwp_linux_dmabuf_v1_api API
+ * See @ref iface_zwp_linux_dmabuf_v1.
+ */
+/**
+ * @defgroup iface_zwp_linux_dmabuf_v1 The zwp_linux_dmabuf_v1 interface
+ *
+ * Following the interfaces from:
+ * https://www.khronos.org/registry/egl/extensions/EXT/EGL_EXT_image_dma_buf_import.txt
+ * and the Linux DRM sub-system's AddFb2 ioctl.
+ *
+ * This interface offers a way to create generic dmabuf-based
+ * wl_buffers. Immediately after a client binds to this interface,
+ * the set of supported formats is sent with 'format' events.
+ *
+ * The following are required from clients:
+ *
+ * - Clients must ensure that either all data in the dma-buf is
+ * coherent for all subsequent read access or that coherency is
+ * correctly handled by the underlying kernel-side dma-buf
+ * implementation.
+ *
+ * - Don't make any more attachments after sending the buffer to the
+ * compositor. Making more attachments later increases the risk of
+ * the compositor not being able to use (re-import) an existing
+ * dmabuf-based wl_buffer.
+ *
+ * The underlying graphics stack must ensure the following:
+ *
+ * - The dmabuf file descriptors relayed to the server will stay valid
+ * for the whole lifetime of the wl_buffer. This means the server may
+ * at any time use those fds to import the dmabuf into any kernel
+ * sub-system that might accept it.
+ *
+ * To create a wl_buffer from one or more dmabufs, a client creates a
+ * zwp_linux_dmabuf_params_v1 object with a zwp_linux_dmabuf_v1.create_params
+ * request. All planes required by the intended format are added with
+ * the 'add' request. Finally, a 'create' request is issued. The server
+ * will reply with either a 'created' event which provides the final
+ * wl_buffer or a 'failed' event saying that it cannot use the dmabufs
+ * provided.
+ *
+ * Warning! The protocol described in this file is experimental and
+ * backward incompatible changes may be made. Backward compatible changes
+ * may be added together with the corresponding interface version bump.
+ * Backward incompatible changes are done by bumping the version number in
+ * the protocol and interface names and resetting the interface version.
+ * Once the protocol is to be declared stable, the 'z' prefix and the
+ * version number in the protocol and interface names are removed and the
+ * interface version number is reset.
+ */
+extern const struct wl_interface zwp_linux_dmabuf_v1_interface;
+/**
+ * @page page_iface_zwp_linux_buffer_params_v1 zwp_linux_buffer_params_v1
+ * @section page_iface_zwp_linux_buffer_params_v1_desc Description
+ *
+ * This temporary object is a collection of dmabufs and other
+ * parameters that together form a single logical buffer. The temporary
+ * object may eventually create one wl_buffer unless cancelled by
+ * destroying it before requesting 'create'.
+ *
+ * Single-planar formats only require one dmabuf, however
+ * multi-planar formats may require more than one dmabuf. For all
+ * formats, an 'add' request must be called once per plane (even if the
+ * underlying dmabuf fd is identical).
+ *
+ * You must use consecutive plane indices ('plane_idx' argument for 'add')
+ * from zero to the number of planes used by the drm_fourcc format code.
+ * All planes required by the format must be given exactly once, but can
+ * be given in any order. Each plane index can be set only once.
+ * @section page_iface_zwp_linux_buffer_params_v1_api API
+ * See @ref iface_zwp_linux_buffer_params_v1.
+ */
+/**
+ * @defgroup iface_zwp_linux_buffer_params_v1 The zwp_linux_buffer_params_v1 interface
+ *
+ * This temporary object is a collection of dmabufs and other
+ * parameters that together form a single logical buffer. The temporary
+ * object may eventually create one wl_buffer unless cancelled by
+ * destroying it before requesting 'create'.
+ *
+ * Single-planar formats only require one dmabuf, however
+ * multi-planar formats may require more than one dmabuf. For all
+ * formats, an 'add' request must be called once per plane (even if the
+ * underlying dmabuf fd is identical).
+ *
+ * You must use consecutive plane indices ('plane_idx' argument for 'add')
+ * from zero to the number of planes used by the drm_fourcc format code.
+ * All planes required by the format must be given exactly once, but can
+ * be given in any order. Each plane index can be set only once.
+ */
+extern const struct wl_interface zwp_linux_buffer_params_v1_interface;
+
+/**
+ * @ingroup iface_zwp_linux_dmabuf_v1
+ * @struct zwp_linux_dmabuf_v1_listener
+ */
+struct zwp_linux_dmabuf_v1_listener {
+	/**
+	 * supported buffer format
+	 *
+	 * This event advertises one buffer format that the server
+	 * supports. All the supported formats are advertised once when the
+	 * client binds to this interface. A roundtrip after binding
+	 * guarantees that the client has received all supported formats.
+	 *
+	 * For the definition of the format codes, see create request.
+	 *
+	 * XXX: Can a compositor ever enumerate them?
+	 * @param format DRM_FORMAT code
+	 */
+	void (*format)(void *data,
+		       struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1,
+		       uint32_t format);
+};
+
+/**
+ * @ingroup iface_zwp_linux_dmabuf_v1
+ */
+static inline int
+zwp_linux_dmabuf_v1_add_listener(struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1,
+				 const struct zwp_linux_dmabuf_v1_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zwp_linux_dmabuf_v1,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZWP_LINUX_DMABUF_V1_DESTROY 0
+#define ZWP_LINUX_DMABUF_V1_CREATE_PARAMS 1
+
+/**
+ * @ingroup iface_zwp_linux_dmabuf_v1
+ */
+#define ZWP_LINUX_DMABUF_V1_FORMAT_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zwp_linux_dmabuf_v1
+ */
+#define ZWP_LINUX_DMABUF_V1_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_linux_dmabuf_v1
+ */
+#define ZWP_LINUX_DMABUF_V1_CREATE_PARAMS_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_linux_dmabuf_v1 */
+static inline void
+zwp_linux_dmabuf_v1_set_user_data(struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_linux_dmabuf_v1, user_data);
+}
+
+/** @ingroup iface_zwp_linux_dmabuf_v1 */
+static inline void *
+zwp_linux_dmabuf_v1_get_user_data(struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_linux_dmabuf_v1);
+}
+
+static inline uint32_t
+zwp_linux_dmabuf_v1_get_version(struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_linux_dmabuf_v1);
+}
+
+/**
+ * @ingroup iface_zwp_linux_dmabuf_v1
+ *
+ * Objects created through this interface, especially wl_buffers, will
+ * remain valid.
+ */
+static inline void
+zwp_linux_dmabuf_v1_destroy(struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_linux_dmabuf_v1,
+			 ZWP_LINUX_DMABUF_V1_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zwp_linux_dmabuf_v1);
+}
+
+/**
+ * @ingroup iface_zwp_linux_dmabuf_v1
+ *
+ * This temporary object is used to collect multiple dmabuf handles into
+ * a single batch to create a wl_buffer. It can only be used once and
+ * should be destroyed after a 'created' or 'failed' event has been
+ * received.
+ */
+static inline struct zwp_linux_buffer_params_v1 *
+zwp_linux_dmabuf_v1_create_params(struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1)
+{
+	struct wl_proxy *params_id;
+
+	params_id = wl_proxy_marshal_constructor((struct wl_proxy *) zwp_linux_dmabuf_v1,
+			 ZWP_LINUX_DMABUF_V1_CREATE_PARAMS, &zwp_linux_buffer_params_v1_interface, NULL);
+
+	return (struct zwp_linux_buffer_params_v1 *) params_id;
+}
+
+#ifndef ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_ENUM
+#define ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_ENUM
+enum zwp_linux_buffer_params_v1_error {
+	/**
+	 * the dmabuf_batch object has already been used to create a wl_buffer
+	 */
+	ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_ALREADY_USED = 0,
+	/**
+	 * plane index out of bounds
+	 */
+	ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_PLANE_IDX = 1,
+	/**
+	 * the plane index was already set
+	 */
+	ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_PLANE_SET = 2,
+	/**
+	 * missing or too many planes to create a buffer
+	 */
+	ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_INCOMPLETE = 3,
+	/**
+	 * format not supported
+	 */
+	ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_INVALID_FORMAT = 4,
+	/**
+	 * invalid width or height
+	 */
+	ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_INVALID_DIMENSIONS = 5,
+	/**
+	 * offset + stride * height goes out of dmabuf bounds
+	 */
+	ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_OUT_OF_BOUNDS = 6,
+};
+#endif /* ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_ENUM */
+
+#ifndef ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_ENUM
+#define ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_ENUM
+enum zwp_linux_buffer_params_v1_flags {
+	/**
+	 * contents are y-inverted
+	 */
+	ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_Y_INVERT = 1,
+	/**
+	 * content is interlaced
+	 */
+	ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_INTERLACED = 2,
+	/**
+	 * bottom field first
+	 */
+	ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_BOTTOM_FIRST = 4,
+};
+#endif /* ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_ENUM */
+
+/**
+ * @ingroup iface_zwp_linux_buffer_params_v1
+ * @struct zwp_linux_buffer_params_v1_listener
+ */
+struct zwp_linux_buffer_params_v1_listener {
+	/**
+	 * buffer creation succeeded
+	 *
+	 * This event indicates that the attempted buffer creation was
+	 * successful. It provides the new wl_buffer referencing the
+	 * dmabuf(s).
+	 *
+	 * Upon receiving this event, the client should destroy the
+	 * zlinux_dmabuf_params object.
+	 * @param buffer the newly created wl_buffer
+	 */
+	void (*created)(void *data,
+			struct zwp_linux_buffer_params_v1 *zwp_linux_buffer_params_v1,
+			struct wl_buffer *buffer);
+	/**
+	 * buffer creation failed
+	 *
+	 * This event indicates that the attempted buffer creation has
+	 * failed. It usually means that one of the dmabuf constraints has
+	 * not been fulfilled.
+	 *
+	 * Upon receiving this event, the client should destroy the
+	 * zlinux_buffer_params object.
+	 */
+	void (*failed)(void *data,
+		       struct zwp_linux_buffer_params_v1 *zwp_linux_buffer_params_v1);
+};
+
+/**
+ * @ingroup iface_zwp_linux_buffer_params_v1
+ */
+static inline int
+zwp_linux_buffer_params_v1_add_listener(struct zwp_linux_buffer_params_v1 *zwp_linux_buffer_params_v1,
+					const struct zwp_linux_buffer_params_v1_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zwp_linux_buffer_params_v1,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZWP_LINUX_BUFFER_PARAMS_V1_DESTROY 0
+#define ZWP_LINUX_BUFFER_PARAMS_V1_ADD 1
+#define ZWP_LINUX_BUFFER_PARAMS_V1_CREATE 2
+
+/**
+ * @ingroup iface_zwp_linux_buffer_params_v1
+ */
+#define ZWP_LINUX_BUFFER_PARAMS_V1_CREATED_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_linux_buffer_params_v1
+ */
+#define ZWP_LINUX_BUFFER_PARAMS_V1_FAILED_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zwp_linux_buffer_params_v1
+ */
+#define ZWP_LINUX_BUFFER_PARAMS_V1_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_linux_buffer_params_v1
+ */
+#define ZWP_LINUX_BUFFER_PARAMS_V1_ADD_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_linux_buffer_params_v1
+ */
+#define ZWP_LINUX_BUFFER_PARAMS_V1_CREATE_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_linux_buffer_params_v1 */
+static inline void
+zwp_linux_buffer_params_v1_set_user_data(struct zwp_linux_buffer_params_v1 *zwp_linux_buffer_params_v1, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_linux_buffer_params_v1, user_data);
+}
+
+/** @ingroup iface_zwp_linux_buffer_params_v1 */
+static inline void *
+zwp_linux_buffer_params_v1_get_user_data(struct zwp_linux_buffer_params_v1 *zwp_linux_buffer_params_v1)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_linux_buffer_params_v1);
+}
+
+static inline uint32_t
+zwp_linux_buffer_params_v1_get_version(struct zwp_linux_buffer_params_v1 *zwp_linux_buffer_params_v1)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_linux_buffer_params_v1);
+}
+
+/**
+ * @ingroup iface_zwp_linux_buffer_params_v1
+ *
+ * Cleans up the temporary data sent to the server for dmabuf-based
+ * wl_buffer creation.
+ */
+static inline void
+zwp_linux_buffer_params_v1_destroy(struct zwp_linux_buffer_params_v1 *zwp_linux_buffer_params_v1)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_linux_buffer_params_v1,
+			 ZWP_LINUX_BUFFER_PARAMS_V1_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zwp_linux_buffer_params_v1);
+}
+
+/**
+ * @ingroup iface_zwp_linux_buffer_params_v1
+ *
+ * This request adds one dmabuf to the set in this
+ * zwp_linux_buffer_params_v1.
+ *
+ * The 64-bit unsigned value combined from modifier_hi and modifier_lo
+ * is the dmabuf layout modifier. DRM AddFB2 ioctl calls this the
+ * fb modifier, which is defined in drm_mode.h of Linux UAPI.
+ * This is an opaque token. Drivers use this token to express tiling,
+ * compression, etc. driver-specific modifications to the base format
+ * defined by the DRM fourcc code.
+ *
+ * This request raises the PLANE_IDX error if plane_idx is too large.
+ * The error PLANE_SET is raised if attempting to set a plane that
+ * was already set.
+ */
+static inline void
+zwp_linux_buffer_params_v1_add(struct zwp_linux_buffer_params_v1 *zwp_linux_buffer_params_v1, int32_t fd, uint32_t plane_idx, uint32_t offset, uint32_t stride, uint32_t modifier_hi, uint32_t modifier_lo)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_linux_buffer_params_v1,
+			 ZWP_LINUX_BUFFER_PARAMS_V1_ADD, fd, plane_idx, offset, stride, modifier_hi, modifier_lo);
+}
+
+/**
+ * @ingroup iface_zwp_linux_buffer_params_v1
+ *
+ * This asks for creation of a wl_buffer from the added dmabuf
+ * buffers. The wl_buffer is not created immediately but returned via
+ * the 'created' event if the dmabuf sharing succeeds. The sharing
+ * may fail at runtime for reasons a client cannot predict, in
+ * which case the 'failed' event is triggered.
+ *
+ * The 'format' argument is a DRM_FORMAT code, as defined by the
+ * libdrm's drm_fourcc.h. The Linux kernel's DRM sub-system is the
+ * authoritative source on how the format codes should work.
+ *
+ * The 'flags' is a bitfield of the flags defined in enum "flags".
+ * 'y_invert' means the that the image needs to be y-flipped.
+ *
+ * Flag 'interlaced' means that the frame in the buffer is not
+ * progressive as usual, but interlaced. An interlaced buffer as
+ * supported here must always contain both top and bottom fields.
+ * The top field always begins on the first pixel row. The temporal
+ * ordering between the two fields is top field first, unless
+ * 'bottom_first' is specified. It is undefined whether 'bottom_first'
+ * is ignored if 'interlaced' is not set.
+ *
+ * This protocol does not convey any information about field rate,
+ * duration, or timing, other than the relative ordering between the
+ * two fields in one buffer. A compositor may have to estimate the
+ * intended field rate from the incoming buffer rate. It is undefined
+ * whether the time of receiving wl_surface.commit with a new buffer
+ * attached, applying the wl_surface state, wl_surface.frame callback
+ * trigger, presentation, or any other point in the compositor cycle
+ * is used to measure the frame or field times. There is no support
+ * for detecting missed or late frames/fields/buffers either, and
+ * there is no support whatsoever for cooperating with interlaced
+ * compositor output.
+ *
+ * The composited image quality resulting from the use of interlaced
+ * buffers is explicitly undefined. A compositor may use elaborate
+ * hardware features or software to deinterlace and create progressive
+ * output frames from a sequence of interlaced input buffers, or it
+ * may produce substandard image quality. However, compositors that
+ * cannot guarantee reasonable image quality in all cases are recommended
+ * to just reject all interlaced buffers.
+ *
+ * Any argument errors, including non-positive width or height,
+ * mismatch between the number of planes and the format, bad
+ * format, bad offset or stride, may be indicated by fatal protocol
+ * errors: INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS,
+ * OUT_OF_BOUNDS.
+ *
+ * Dmabuf import errors in the server that are not obvious client
+ * bugs are returned via the 'failed' event as non-fatal. This
+ * allows attempting dmabuf sharing and falling back in the client
+ * if it fails.
+ *
+ * This request can be sent only once in the object's lifetime, after
+ * which the only legal request is destroy. This object should be
+ * destroyed after issuing a 'create' request. Attempting to use this
+ * object after issuing 'create' raises ALREADY_USED protocol error.
+ *
+ * It is not mandatory to issue 'create'. If a client wants to
+ * cancel the buffer creation, it can just destroy this object.
+ */
+static inline void
+zwp_linux_buffer_params_v1_create(struct zwp_linux_buffer_params_v1 *zwp_linux_buffer_params_v1, int32_t width, int32_t height, uint32_t format, uint32_t flags)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_linux_buffer_params_v1,
+			 ZWP_LINUX_BUFFER_PARAMS_V1_CREATE, width, height, format, flags);
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/ext/wayland/viewporter-client-protocol.h b/ext/wayland/viewporter-client-protocol.h
new file mode 100644
index 0000000..76af360
--- /dev/null
+++ b/ext/wayland/viewporter-client-protocol.h
@@ -0,0 +1,408 @@
+/* Generated by wayland-scanner 1.13.0 */
+
+#ifndef VIEWPORTER_CLIENT_PROTOCOL_H
+#define VIEWPORTER_CLIENT_PROTOCOL_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include "wayland-client.h"
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @page page_viewporter The viewporter protocol
+ * @section page_ifaces_viewporter Interfaces
+ * - @subpage page_iface_wp_viewporter - surface cropping and scaling
+ * - @subpage page_iface_wp_viewport - crop and scale interface to a wl_surface
+ * @section page_copyright_viewporter Copyright
+ * <pre>
+ *
+ * Copyright Â© 2013-2016 Collabora, Ltd.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * </pre>
+ */
+struct wl_surface;
+struct wp_viewport;
+struct wp_viewporter;
+
+/**
+ * @page page_iface_wp_viewporter wp_viewporter
+ * @section page_iface_wp_viewporter_desc Description
+ *
+ * The global interface exposing surface cropping and scaling
+ * capabilities is used to instantiate an interface extension for a
+ * wl_surface object. This extended interface will then allow
+ * cropping and scaling the surface contents, effectively
+ * disconnecting the direct relationship between the buffer and the
+ * surface size.
+ * @section page_iface_wp_viewporter_api API
+ * See @ref iface_wp_viewporter.
+ */
+/**
+ * @defgroup iface_wp_viewporter The wp_viewporter interface
+ *
+ * The global interface exposing surface cropping and scaling
+ * capabilities is used to instantiate an interface extension for a
+ * wl_surface object. This extended interface will then allow
+ * cropping and scaling the surface contents, effectively
+ * disconnecting the direct relationship between the buffer and the
+ * surface size.
+ */
+extern const struct wl_interface wp_viewporter_interface;
+/**
+ * @page page_iface_wp_viewport wp_viewport
+ * @section page_iface_wp_viewport_desc Description
+ *
+ * An additional interface to a wl_surface object, which allows the
+ * client to specify the cropping and scaling of the surface
+ * contents.
+ *
+ * This interface works with two concepts: the source rectangle (src_x,
+ * src_y, src_width, src_height), and the destination size (dst_width,
+ * dst_height). The contents of the source rectangle are scaled to the
+ * destination size, and content outside the source rectangle is ignored.
+ * This state is double-buffered, and is applied on the next
+ * wl_surface.commit.
+ *
+ * The two parts of crop and scale state are independent: the source
+ * rectangle, and the destination size. Initially both are unset, that
+ * is, no scaling is applied. The whole of the current wl_buffer is
+ * used as the source, and the surface size is as defined in
+ * wl_surface.attach.
+ *
+ * If the destination size is set, it causes the surface size to become
+ * dst_width, dst_height. The source (rectangle) is scaled to exactly
+ * this size. This overrides whatever the attached wl_buffer size is,
+ * unless the wl_buffer is NULL. If the wl_buffer is NULL, the surface
+ * has no content and therefore no size. Otherwise, the size is always
+ * at least 1x1 in surface local coordinates.
+ *
+ * If the source rectangle is set, it defines what area of the wl_buffer is
+ * taken as the source. If the source rectangle is set and the destination
+ * size is not set, then src_width and src_height must be integers, and the
+ * surface size becomes the source rectangle size. This results in cropping
+ * without scaling. If src_width or src_height are not integers and
+ * destination size is not set, the bad_size protocol error is raised when
+ * the surface state is applied.
+ *
+ * The coordinate transformations from buffer pixel coordinates up to
+ * the surface-local coordinates happen in the following order:
+ * 1. buffer_transform (wl_surface.set_buffer_transform)
+ * 2. buffer_scale (wl_surface.set_buffer_scale)
+ * 3. crop and scale (wp_viewport.set*)
+ * This means, that the source rectangle coordinates of crop and scale
+ * are given in the coordinates after the buffer transform and scale,
+ * i.e. in the coordinates that would be the surface-local coordinates
+ * if the crop and scale was not applied.
+ *
+ * If src_x or src_y are negative, the bad_value protocol error is raised.
+ * Otherwise, if the source rectangle is partially or completely outside of
+ * the non-NULL wl_buffer, then the out_of_buffer protocol error is raised
+ * when the surface state is applied. A NULL wl_buffer does not raise the
+ * out_of_buffer error.
+ *
+ * The x, y arguments of wl_surface.attach are applied as normal to
+ * the surface. They indicate how many pixels to remove from the
+ * surface size from the left and the top. In other words, they are
+ * still in the surface-local coordinate system, just like dst_width
+ * and dst_height are.
+ *
+ * If the wl_surface associated with the wp_viewport is destroyed,
+ * all wp_viewport requests except 'destroy' raise the protocol error
+ * no_surface.
+ *
+ * If the wp_viewport object is destroyed, the crop and scale
+ * state is removed from the wl_surface. The change will be applied
+ * on the next wl_surface.commit.
+ * @section page_iface_wp_viewport_api API
+ * See @ref iface_wp_viewport.
+ */
+/**
+ * @defgroup iface_wp_viewport The wp_viewport interface
+ *
+ * An additional interface to a wl_surface object, which allows the
+ * client to specify the cropping and scaling of the surface
+ * contents.
+ *
+ * This interface works with two concepts: the source rectangle (src_x,
+ * src_y, src_width, src_height), and the destination size (dst_width,
+ * dst_height). The contents of the source rectangle are scaled to the
+ * destination size, and content outside the source rectangle is ignored.
+ * This state is double-buffered, and is applied on the next
+ * wl_surface.commit.
+ *
+ * The two parts of crop and scale state are independent: the source
+ * rectangle, and the destination size. Initially both are unset, that
+ * is, no scaling is applied. The whole of the current wl_buffer is
+ * used as the source, and the surface size is as defined in
+ * wl_surface.attach.
+ *
+ * If the destination size is set, it causes the surface size to become
+ * dst_width, dst_height. The source (rectangle) is scaled to exactly
+ * this size. This overrides whatever the attached wl_buffer size is,
+ * unless the wl_buffer is NULL. If the wl_buffer is NULL, the surface
+ * has no content and therefore no size. Otherwise, the size is always
+ * at least 1x1 in surface local coordinates.
+ *
+ * If the source rectangle is set, it defines what area of the wl_buffer is
+ * taken as the source. If the source rectangle is set and the destination
+ * size is not set, then src_width and src_height must be integers, and the
+ * surface size becomes the source rectangle size. This results in cropping
+ * without scaling. If src_width or src_height are not integers and
+ * destination size is not set, the bad_size protocol error is raised when
+ * the surface state is applied.
+ *
+ * The coordinate transformations from buffer pixel coordinates up to
+ * the surface-local coordinates happen in the following order:
+ * 1. buffer_transform (wl_surface.set_buffer_transform)
+ * 2. buffer_scale (wl_surface.set_buffer_scale)
+ * 3. crop and scale (wp_viewport.set*)
+ * This means, that the source rectangle coordinates of crop and scale
+ * are given in the coordinates after the buffer transform and scale,
+ * i.e. in the coordinates that would be the surface-local coordinates
+ * if the crop and scale was not applied.
+ *
+ * If src_x or src_y are negative, the bad_value protocol error is raised.
+ * Otherwise, if the source rectangle is partially or completely outside of
+ * the non-NULL wl_buffer, then the out_of_buffer protocol error is raised
+ * when the surface state is applied. A NULL wl_buffer does not raise the
+ * out_of_buffer error.
+ *
+ * The x, y arguments of wl_surface.attach are applied as normal to
+ * the surface. They indicate how many pixels to remove from the
+ * surface size from the left and the top. In other words, they are
+ * still in the surface-local coordinate system, just like dst_width
+ * and dst_height are.
+ *
+ * If the wl_surface associated with the wp_viewport is destroyed,
+ * all wp_viewport requests except 'destroy' raise the protocol error
+ * no_surface.
+ *
+ * If the wp_viewport object is destroyed, the crop and scale
+ * state is removed from the wl_surface. The change will be applied
+ * on the next wl_surface.commit.
+ */
+extern const struct wl_interface wp_viewport_interface;
+
+#ifndef WP_VIEWPORTER_ERROR_ENUM
+#define WP_VIEWPORTER_ERROR_ENUM
+enum wp_viewporter_error {
+	/**
+	 * the surface already has a viewport object associated
+	 */
+	WP_VIEWPORTER_ERROR_VIEWPORT_EXISTS = 0,
+};
+#endif /* WP_VIEWPORTER_ERROR_ENUM */
+
+#define WP_VIEWPORTER_DESTROY 0
+#define WP_VIEWPORTER_GET_VIEWPORT 1
+
+
+/**
+ * @ingroup iface_wp_viewporter
+ */
+#define WP_VIEWPORTER_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_wp_viewporter
+ */
+#define WP_VIEWPORTER_GET_VIEWPORT_SINCE_VERSION 1
+
+/** @ingroup iface_wp_viewporter */
+static inline void
+wp_viewporter_set_user_data(struct wp_viewporter *wp_viewporter, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) wp_viewporter, user_data);
+}
+
+/** @ingroup iface_wp_viewporter */
+static inline void *
+wp_viewporter_get_user_data(struct wp_viewporter *wp_viewporter)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) wp_viewporter);
+}
+
+static inline uint32_t
+wp_viewporter_get_version(struct wp_viewporter *wp_viewporter)
+{
+	return wl_proxy_get_version((struct wl_proxy *) wp_viewporter);
+}
+
+/**
+ * @ingroup iface_wp_viewporter
+ *
+ * Informs the server that the client will not be using this
+ * protocol object anymore. This does not affect any other objects,
+ * wp_viewport objects included.
+ */
+static inline void
+wp_viewporter_destroy(struct wp_viewporter *wp_viewporter)
+{
+	wl_proxy_marshal((struct wl_proxy *) wp_viewporter,
+			 WP_VIEWPORTER_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) wp_viewporter);
+}
+
+/**
+ * @ingroup iface_wp_viewporter
+ *
+ * Instantiate an interface extension for the given wl_surface to
+ * crop and scale its content. If the given wl_surface already has
+ * a wp_viewport object associated, the viewport_exists
+ * protocol error is raised.
+ */
+static inline struct wp_viewport *
+wp_viewporter_get_viewport(struct wp_viewporter *wp_viewporter, struct wl_surface *surface)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) wp_viewporter,
+			 WP_VIEWPORTER_GET_VIEWPORT, &wp_viewport_interface, NULL, surface);
+
+	return (struct wp_viewport *) id;
+}
+
+#ifndef WP_VIEWPORT_ERROR_ENUM
+#define WP_VIEWPORT_ERROR_ENUM
+enum wp_viewport_error {
+	/**
+	 * negative or zero values in width or height
+	 */
+	WP_VIEWPORT_ERROR_BAD_VALUE = 0,
+	/**
+	 * destination size is not integer
+	 */
+	WP_VIEWPORT_ERROR_BAD_SIZE = 1,
+	/**
+	 * source rectangle extends outside of the content area
+	 */
+	WP_VIEWPORT_ERROR_OUT_OF_BUFFER = 2,
+	/**
+	 * the wl_surface was destroyed
+	 */
+	WP_VIEWPORT_ERROR_NO_SURFACE = 3,
+};
+#endif /* WP_VIEWPORT_ERROR_ENUM */
+
+#define WP_VIEWPORT_DESTROY 0
+#define WP_VIEWPORT_SET_SOURCE 1
+#define WP_VIEWPORT_SET_DESTINATION 2
+
+
+/**
+ * @ingroup iface_wp_viewport
+ */
+#define WP_VIEWPORT_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_wp_viewport
+ */
+#define WP_VIEWPORT_SET_SOURCE_SINCE_VERSION 1
+/**
+ * @ingroup iface_wp_viewport
+ */
+#define WP_VIEWPORT_SET_DESTINATION_SINCE_VERSION 1
+
+/** @ingroup iface_wp_viewport */
+static inline void
+wp_viewport_set_user_data(struct wp_viewport *wp_viewport, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) wp_viewport, user_data);
+}
+
+/** @ingroup iface_wp_viewport */
+static inline void *
+wp_viewport_get_user_data(struct wp_viewport *wp_viewport)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) wp_viewport);
+}
+
+static inline uint32_t
+wp_viewport_get_version(struct wp_viewport *wp_viewport)
+{
+	return wl_proxy_get_version((struct wl_proxy *) wp_viewport);
+}
+
+/**
+ * @ingroup iface_wp_viewport
+ *
+ * The associated wl_surface's crop and scale state is removed.
+ * The change is applied on the next wl_surface.commit.
+ */
+static inline void
+wp_viewport_destroy(struct wp_viewport *wp_viewport)
+{
+	wl_proxy_marshal((struct wl_proxy *) wp_viewport,
+			 WP_VIEWPORT_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) wp_viewport);
+}
+
+/**
+ * @ingroup iface_wp_viewport
+ *
+ * Set the source rectangle of the associated wl_surface. See
+ * wp_viewport for the description, and relation to the wl_buffer
+ * size.
+ *
+ * If all of x, y, width and height are -1.0, the source rectangle is
+ * unset instead. Any other set of values where width or height are zero
+ * or negative, or x or y are negative, raise the bad_value protocol
+ * error.
+ *
+ * The crop and scale state is double-buffered state, and will be
+ * applied on the next wl_surface.commit.
+ */
+static inline void
+wp_viewport_set_source(struct wp_viewport *wp_viewport, wl_fixed_t x, wl_fixed_t y, wl_fixed_t width, wl_fixed_t height)
+{
+	wl_proxy_marshal((struct wl_proxy *) wp_viewport,
+			 WP_VIEWPORT_SET_SOURCE, x, y, width, height);
+}
+
+/**
+ * @ingroup iface_wp_viewport
+ *
+ * Set the destination size of the associated wl_surface. See
+ * wp_viewport for the description, and relation to the wl_buffer
+ * size.
+ *
+ * If width is -1 and height is -1, the destination size is unset
+ * instead. Any other pair of values for width and height that
+ * contains zero or negative values raises the bad_value protocol
+ * error.
+ *
+ * The crop and scale state is double-buffered state, and will be
+ * applied on the next wl_surface.commit.
+ */
+static inline void
+wp_viewport_set_destination(struct wp_viewport *wp_viewport, int32_t width, int32_t height)
+{
+	wl_proxy_marshal((struct wl_proxy *) wp_viewport,
+			 WP_VIEWPORT_SET_DESTINATION, width, height);
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/ext/wayland/viewporter-protocol.c b/ext/wayland/viewporter-protocol.c
new file mode 100644
index 0000000..8bc362c
--- /dev/null
+++ b/ext/wayland/viewporter-protocol.c
@@ -0,0 +1,64 @@
+/* Generated by wayland-scanner 1.13.0 */
+
+/*
+ * Copyright Â© 2013-2016 Collabora, Ltd.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+#include "wayland-util.h"
+
+extern const struct wl_interface wl_surface_interface;
+extern const struct wl_interface wp_viewport_interface;
+
+static const struct wl_interface *types[] = {
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	&wp_viewport_interface,
+	&wl_surface_interface,
+};
+
+static const struct wl_message wp_viewporter_requests[] = {
+	{ "destroy", "", types + 0 },
+	{ "get_viewport", "no", types + 4 },
+};
+
+WL_EXPORT const struct wl_interface wp_viewporter_interface = {
+	"wp_viewporter", 1,
+	2, wp_viewporter_requests,
+	0, NULL,
+};
+
+static const struct wl_message wp_viewport_requests[] = {
+	{ "destroy", "", types + 0 },
+	{ "set_source", "ffff", types + 0 },
+	{ "set_destination", "ii", types + 0 },
+};
+
+WL_EXPORT const struct wl_interface wp_viewport_interface = {
+	"wp_viewport", 1,
+	3, wp_viewport_requests,
+	0, NULL,
+};
+
diff --git a/ext/wayland/xdg-shell-unstable-v6-client-protocol.h b/ext/wayland/xdg-shell-unstable-v6-client-protocol.h
new file mode 100644
index 0000000..14cc9ad
--- /dev/null
+++ b/ext/wayland/xdg-shell-unstable-v6-client-protocol.h
@@ -0,0 +1,1744 @@
+/* Generated by wayland-scanner 1.13.0 */
+
+#ifndef XDG_SHELL_UNSTABLE_V6_CLIENT_PROTOCOL_H
+#define XDG_SHELL_UNSTABLE_V6_CLIENT_PROTOCOL_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include "wayland-client.h"
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @page page_xdg_shell_unstable_v6 The xdg_shell_unstable_v6 protocol
+ * @section page_ifaces_xdg_shell_unstable_v6 Interfaces
+ * - @subpage page_iface_zxdg_shell_v6 - create desktop-style surfaces
+ * - @subpage page_iface_zxdg_positioner_v6 - child surface positioner
+ * - @subpage page_iface_zxdg_surface_v6 - desktop user interface surface base interface
+ * - @subpage page_iface_zxdg_toplevel_v6 - toplevel surface
+ * - @subpage page_iface_zxdg_popup_v6 - short-lived, popup surfaces for menus
+ * @section page_copyright_xdg_shell_unstable_v6 Copyright
+ * <pre>
+ *
+ * Copyright Â© 2008-2013 Kristian HÃ¸gsberg
+ * Copyright Â© 2013      Rafael Antognolli
+ * Copyright Â© 2013      Jasper St. Pierre
+ * Copyright Â© 2010-2013 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * </pre>
+ */
+struct wl_output;
+struct wl_seat;
+struct wl_surface;
+struct zxdg_popup_v6;
+struct zxdg_positioner_v6;
+struct zxdg_shell_v6;
+struct zxdg_surface_v6;
+struct zxdg_toplevel_v6;
+
+/**
+ * @page page_iface_zxdg_shell_v6 zxdg_shell_v6
+ * @section page_iface_zxdg_shell_v6_desc Description
+ *
+ * xdg_shell allows clients to turn a wl_surface into a "real window"
+ * which can be dragged, resized, stacked, and moved around by the
+ * user. Everything about this interface is suited towards traditional
+ * desktop environments.
+ * @section page_iface_zxdg_shell_v6_api API
+ * See @ref iface_zxdg_shell_v6.
+ */
+/**
+ * @defgroup iface_zxdg_shell_v6 The zxdg_shell_v6 interface
+ *
+ * xdg_shell allows clients to turn a wl_surface into a "real window"
+ * which can be dragged, resized, stacked, and moved around by the
+ * user. Everything about this interface is suited towards traditional
+ * desktop environments.
+ */
+extern const struct wl_interface zxdg_shell_v6_interface;
+/**
+ * @page page_iface_zxdg_positioner_v6 zxdg_positioner_v6
+ * @section page_iface_zxdg_positioner_v6_desc Description
+ *
+ * The xdg_positioner provides a collection of rules for the placement of a
+ * child surface relative to a parent surface. Rules can be defined to ensure
+ * the child surface remains within the visible area's borders, and to
+ * specify how the child surface changes its position, such as sliding along
+ * an axis, or flipping around a rectangle.
+ *
+ * See the various requests for details about possible rules.
+ *
+ * At the time of the request, the compositor makes a copy of the rules
+ * specified by the xdg_positioner. Thus, after the request is complete the
+ * xdg_positioner object can be destroyed or reused; further changes to the
+ * object will have no effect on previous usages.
+ *
+ * For an xdg_positioner object to be considered complete, it must have a
+ * non-zero size set by set_size, and a non-zero anchor rectangle set by
+ * set_anchor_rect. Passing an incomplete xdg_positioner object when
+ * positioning a surface raises an error.
+ * @section page_iface_zxdg_positioner_v6_api API
+ * See @ref iface_zxdg_positioner_v6.
+ */
+/**
+ * @defgroup iface_zxdg_positioner_v6 The zxdg_positioner_v6 interface
+ *
+ * The xdg_positioner provides a collection of rules for the placement of a
+ * child surface relative to a parent surface. Rules can be defined to ensure
+ * the child surface remains within the visible area's borders, and to
+ * specify how the child surface changes its position, such as sliding along
+ * an axis, or flipping around a rectangle.
+ *
+ * See the various requests for details about possible rules.
+ *
+ * At the time of the request, the compositor makes a copy of the rules
+ * specified by the xdg_positioner. Thus, after the request is complete the
+ * xdg_positioner object can be destroyed or reused; further changes to the
+ * object will have no effect on previous usages.
+ *
+ * For an xdg_positioner object to be considered complete, it must have a
+ * non-zero size set by set_size, and a non-zero anchor rectangle set by
+ * set_anchor_rect. Passing an incomplete xdg_positioner object when
+ * positioning a surface raises an error.
+ */
+extern const struct wl_interface zxdg_positioner_v6_interface;
+/**
+ * @page page_iface_zxdg_surface_v6 zxdg_surface_v6
+ * @section page_iface_zxdg_surface_v6_desc Description
+ *
+ * An interface that may be implemented by a wl_surface, for
+ * implementations that provide a desktop-style user interface.
+ *
+ * It provides a base set of functionality required to construct user
+ * interface elements requiring management by the compositor, such as
+ * toplevel windows, menus, etc. The types of functionality are split into
+ * xdg_surface roles.
+ *
+ * Creating an xdg_surface does not set the role for a wl_surface. In order
+ * to map an xdg_surface, the client must create a role-specific object
+ * using, e.g., get_toplevel, get_popup. The wl_surface for any given
+ * xdg_surface can have at most one role, and may not be assigned any role
+ * not based on xdg_surface.
+ *
+ * A role must be assigned before any other requests are made to the
+ * xdg_surface object.
+ *
+ * The client must call wl_surface.commit on the corresponding wl_surface
+ * for the xdg_surface state to take effect.
+ *
+ * Creating an xdg_surface from a wl_surface which has a buffer attached or
+ * committed is a client error, and any attempts by a client to attach or
+ * manipulate a buffer prior to the first xdg_surface.configure call must
+ * also be treated as errors.
+ *
+ * For a surface to be mapped by the compositor, the following conditions
+ * must be met: (1) the client has assigned a xdg_surface based role to the
+ * surface, (2) the client has set and committed the xdg_surface state and
+ * the role dependent state to the surface and (3) the client has committed a
+ * buffer to the surface.
+ * @section page_iface_zxdg_surface_v6_api API
+ * See @ref iface_zxdg_surface_v6.
+ */
+/**
+ * @defgroup iface_zxdg_surface_v6 The zxdg_surface_v6 interface
+ *
+ * An interface that may be implemented by a wl_surface, for
+ * implementations that provide a desktop-style user interface.
+ *
+ * It provides a base set of functionality required to construct user
+ * interface elements requiring management by the compositor, such as
+ * toplevel windows, menus, etc. The types of functionality are split into
+ * xdg_surface roles.
+ *
+ * Creating an xdg_surface does not set the role for a wl_surface. In order
+ * to map an xdg_surface, the client must create a role-specific object
+ * using, e.g., get_toplevel, get_popup. The wl_surface for any given
+ * xdg_surface can have at most one role, and may not be assigned any role
+ * not based on xdg_surface.
+ *
+ * A role must be assigned before any other requests are made to the
+ * xdg_surface object.
+ *
+ * The client must call wl_surface.commit on the corresponding wl_surface
+ * for the xdg_surface state to take effect.
+ *
+ * Creating an xdg_surface from a wl_surface which has a buffer attached or
+ * committed is a client error, and any attempts by a client to attach or
+ * manipulate a buffer prior to the first xdg_surface.configure call must
+ * also be treated as errors.
+ *
+ * For a surface to be mapped by the compositor, the following conditions
+ * must be met: (1) the client has assigned a xdg_surface based role to the
+ * surface, (2) the client has set and committed the xdg_surface state and
+ * the role dependent state to the surface and (3) the client has committed a
+ * buffer to the surface.
+ */
+extern const struct wl_interface zxdg_surface_v6_interface;
+/**
+ * @page page_iface_zxdg_toplevel_v6 zxdg_toplevel_v6
+ * @section page_iface_zxdg_toplevel_v6_desc Description
+ *
+ * This interface defines an xdg_surface role which allows a surface to,
+ * among other things, set window-like properties such as maximize,
+ * fullscreen, and minimize, set application-specific metadata like title and
+ * id, and well as trigger user interactive operations such as interactive
+ * resize and move.
+ * @section page_iface_zxdg_toplevel_v6_api API
+ * See @ref iface_zxdg_toplevel_v6.
+ */
+/**
+ * @defgroup iface_zxdg_toplevel_v6 The zxdg_toplevel_v6 interface
+ *
+ * This interface defines an xdg_surface role which allows a surface to,
+ * among other things, set window-like properties such as maximize,
+ * fullscreen, and minimize, set application-specific metadata like title and
+ * id, and well as trigger user interactive operations such as interactive
+ * resize and move.
+ */
+extern const struct wl_interface zxdg_toplevel_v6_interface;
+/**
+ * @page page_iface_zxdg_popup_v6 zxdg_popup_v6
+ * @section page_iface_zxdg_popup_v6_desc Description
+ *
+ * A popup surface is a short-lived, temporary surface. It can be used to
+ * implement for example menus, popovers, tooltips and other similar user
+ * interface concepts.
+ *
+ * A popup can be made to take an explicit grab. See xdg_popup.grab for
+ * details.
+ *
+ * When the popup is dismissed, a popup_done event will be sent out, and at
+ * the same time the surface will be unmapped. See the xdg_popup.popup_done
+ * event for details.
+ *
+ * Explicitly destroying the xdg_popup object will also dismiss the popup and
+ * unmap the surface. Clients that want to dismiss the popup when another
+ * surface of their own is clicked should dismiss the popup using the destroy
+ * request.
+ *
+ * The parent surface must have either the xdg_toplevel or xdg_popup surface
+ * role.
+ *
+ * A newly created xdg_popup will be stacked on top of all previously created
+ * xdg_popup surfaces associated with the same xdg_toplevel.
+ *
+ * The parent of an xdg_popup must be mapped (see the xdg_surface
+ * description) before the xdg_popup itself.
+ *
+ * The x and y arguments passed when creating the popup object specify
+ * where the top left of the popup should be placed, relative to the
+ * local surface coordinates of the parent surface. See
+ * xdg_surface.get_popup.
+ *
+ * The client must call wl_surface.commit on the corresponding wl_surface
+ * for the xdg_popup state to take effect.
+ * @section page_iface_zxdg_popup_v6_api API
+ * See @ref iface_zxdg_popup_v6.
+ */
+/**
+ * @defgroup iface_zxdg_popup_v6 The zxdg_popup_v6 interface
+ *
+ * A popup surface is a short-lived, temporary surface. It can be used to
+ * implement for example menus, popovers, tooltips and other similar user
+ * interface concepts.
+ *
+ * A popup can be made to take an explicit grab. See xdg_popup.grab for
+ * details.
+ *
+ * When the popup is dismissed, a popup_done event will be sent out, and at
+ * the same time the surface will be unmapped. See the xdg_popup.popup_done
+ * event for details.
+ *
+ * Explicitly destroying the xdg_popup object will also dismiss the popup and
+ * unmap the surface. Clients that want to dismiss the popup when another
+ * surface of their own is clicked should dismiss the popup using the destroy
+ * request.
+ *
+ * The parent surface must have either the xdg_toplevel or xdg_popup surface
+ * role.
+ *
+ * A newly created xdg_popup will be stacked on top of all previously created
+ * xdg_popup surfaces associated with the same xdg_toplevel.
+ *
+ * The parent of an xdg_popup must be mapped (see the xdg_surface
+ * description) before the xdg_popup itself.
+ *
+ * The x and y arguments passed when creating the popup object specify
+ * where the top left of the popup should be placed, relative to the
+ * local surface coordinates of the parent surface. See
+ * xdg_surface.get_popup.
+ *
+ * The client must call wl_surface.commit on the corresponding wl_surface
+ * for the xdg_popup state to take effect.
+ */
+extern const struct wl_interface zxdg_popup_v6_interface;
+
+#ifndef ZXDG_SHELL_V6_ERROR_ENUM
+#define ZXDG_SHELL_V6_ERROR_ENUM
+enum zxdg_shell_v6_error {
+	/**
+	 * given wl_surface has another role
+	 */
+	ZXDG_SHELL_V6_ERROR_ROLE = 0,
+	/**
+	 * xdg_shell was destroyed before children
+	 */
+	ZXDG_SHELL_V6_ERROR_DEFUNCT_SURFACES = 1,
+	/**
+	 * the client tried to map or destroy a non-topmost popup
+	 */
+	ZXDG_SHELL_V6_ERROR_NOT_THE_TOPMOST_POPUP = 2,
+	/**
+	 * the client specified an invalid popup parent surface
+	 */
+	ZXDG_SHELL_V6_ERROR_INVALID_POPUP_PARENT = 3,
+	/**
+	 * the client provided an invalid surface state
+	 */
+	ZXDG_SHELL_V6_ERROR_INVALID_SURFACE_STATE = 4,
+	/**
+	 * the client provided an invalid positioner
+	 */
+	ZXDG_SHELL_V6_ERROR_INVALID_POSITIONER = 5,
+};
+#endif /* ZXDG_SHELL_V6_ERROR_ENUM */
+
+/**
+ * @ingroup iface_zxdg_shell_v6
+ * @struct zxdg_shell_v6_listener
+ */
+struct zxdg_shell_v6_listener {
+	/**
+	 * check if the client is alive
+	 *
+	 * The ping event asks the client if it's still alive. Pass the
+	 * serial specified in the event back to the compositor by sending
+	 * a "pong" request back with the specified serial. See
+	 * xdg_shell.ping.
+	 *
+	 * Compositors can use this to determine if the client is still
+	 * alive. It's unspecified what will happen if the client doesn't
+	 * respond to the ping request, or in what timeframe. Clients
+	 * should try to respond in a reasonable amount of time.
+	 *
+	 * A compositor is free to ping in any way it wants, but a client
+	 * must always respond to any xdg_shell object it created.
+	 * @param serial pass this to the pong request
+	 */
+	void (*ping)(void *data,
+		     struct zxdg_shell_v6 *zxdg_shell_v6,
+		     uint32_t serial);
+};
+
+/**
+ * @ingroup iface_zxdg_shell_v6
+ */
+static inline int
+zxdg_shell_v6_add_listener(struct zxdg_shell_v6 *zxdg_shell_v6,
+			   const struct zxdg_shell_v6_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zxdg_shell_v6,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZXDG_SHELL_V6_DESTROY 0
+#define ZXDG_SHELL_V6_CREATE_POSITIONER 1
+#define ZXDG_SHELL_V6_GET_XDG_SURFACE 2
+#define ZXDG_SHELL_V6_PONG 3
+
+/**
+ * @ingroup iface_zxdg_shell_v6
+ */
+#define ZXDG_SHELL_V6_PING_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zxdg_shell_v6
+ */
+#define ZXDG_SHELL_V6_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_shell_v6
+ */
+#define ZXDG_SHELL_V6_CREATE_POSITIONER_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_shell_v6
+ */
+#define ZXDG_SHELL_V6_GET_XDG_SURFACE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_shell_v6
+ */
+#define ZXDG_SHELL_V6_PONG_SINCE_VERSION 1
+
+/** @ingroup iface_zxdg_shell_v6 */
+static inline void
+zxdg_shell_v6_set_user_data(struct zxdg_shell_v6 *zxdg_shell_v6, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zxdg_shell_v6, user_data);
+}
+
+/** @ingroup iface_zxdg_shell_v6 */
+static inline void *
+zxdg_shell_v6_get_user_data(struct zxdg_shell_v6 *zxdg_shell_v6)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_shell_v6);
+}
+
+static inline uint32_t
+zxdg_shell_v6_get_version(struct zxdg_shell_v6 *zxdg_shell_v6)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zxdg_shell_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_shell_v6
+ *
+ * Destroy this xdg_shell object.
+ *
+ * Destroying a bound xdg_shell object while there are surfaces
+ * still alive created by this xdg_shell object instance is illegal
+ * and will result in a protocol error.
+ */
+static inline void
+zxdg_shell_v6_destroy(struct zxdg_shell_v6 *zxdg_shell_v6)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_shell_v6,
+			 ZXDG_SHELL_V6_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zxdg_shell_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_shell_v6
+ *
+ * Create a positioner object. A positioner object is used to position
+ * surfaces relative to some parent surface. See the interface description
+ * and xdg_surface.get_popup for details.
+ */
+static inline struct zxdg_positioner_v6 *
+zxdg_shell_v6_create_positioner(struct zxdg_shell_v6 *zxdg_shell_v6)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) zxdg_shell_v6,
+			 ZXDG_SHELL_V6_CREATE_POSITIONER, &zxdg_positioner_v6_interface, NULL);
+
+	return (struct zxdg_positioner_v6 *) id;
+}
+
+/**
+ * @ingroup iface_zxdg_shell_v6
+ *
+ * This creates an xdg_surface for the given surface. While xdg_surface
+ * itself is not a role, the corresponding surface may only be assigned
+ * a role extending xdg_surface, such as xdg_toplevel or xdg_popup.
+ *
+ * This creates an xdg_surface for the given surface. An xdg_surface is
+ * used as basis to define a role to a given surface, such as xdg_toplevel
+ * or xdg_popup. It also manages functionality shared between xdg_surface
+ * based surface roles.
+ *
+ * See the documentation of xdg_surface for more details about what an
+ * xdg_surface is and how it is used.
+ */
+static inline struct zxdg_surface_v6 *
+zxdg_shell_v6_get_xdg_surface(struct zxdg_shell_v6 *zxdg_shell_v6, struct wl_surface *surface)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) zxdg_shell_v6,
+			 ZXDG_SHELL_V6_GET_XDG_SURFACE, &zxdg_surface_v6_interface, NULL, surface);
+
+	return (struct zxdg_surface_v6 *) id;
+}
+
+/**
+ * @ingroup iface_zxdg_shell_v6
+ *
+ * A client must respond to a ping event with a pong request or
+ * the client may be deemed unresponsive. See xdg_shell.ping.
+ */
+static inline void
+zxdg_shell_v6_pong(struct zxdg_shell_v6 *zxdg_shell_v6, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_shell_v6,
+			 ZXDG_SHELL_V6_PONG, serial);
+}
+
+#ifndef ZXDG_POSITIONER_V6_ERROR_ENUM
+#define ZXDG_POSITIONER_V6_ERROR_ENUM
+enum zxdg_positioner_v6_error {
+	/**
+	 * invalid input provided
+	 */
+	ZXDG_POSITIONER_V6_ERROR_INVALID_INPUT = 0,
+};
+#endif /* ZXDG_POSITIONER_V6_ERROR_ENUM */
+
+#ifndef ZXDG_POSITIONER_V6_ANCHOR_ENUM
+#define ZXDG_POSITIONER_V6_ANCHOR_ENUM
+enum zxdg_positioner_v6_anchor {
+	/**
+	 * the center of the anchor rectangle
+	 */
+	ZXDG_POSITIONER_V6_ANCHOR_NONE = 0,
+	/**
+	 * the top edge of the anchor rectangle
+	 */
+	ZXDG_POSITIONER_V6_ANCHOR_TOP = 1,
+	/**
+	 * the bottom edge of the anchor rectangle
+	 */
+	ZXDG_POSITIONER_V6_ANCHOR_BOTTOM = 2,
+	/**
+	 * the left edge of the anchor rectangle
+	 */
+	ZXDG_POSITIONER_V6_ANCHOR_LEFT = 4,
+	/**
+	 * the right edge of the anchor rectangle
+	 */
+	ZXDG_POSITIONER_V6_ANCHOR_RIGHT = 8,
+};
+#endif /* ZXDG_POSITIONER_V6_ANCHOR_ENUM */
+
+#ifndef ZXDG_POSITIONER_V6_GRAVITY_ENUM
+#define ZXDG_POSITIONER_V6_GRAVITY_ENUM
+enum zxdg_positioner_v6_gravity {
+	/**
+	 * center over the anchor edge
+	 */
+	ZXDG_POSITIONER_V6_GRAVITY_NONE = 0,
+	/**
+	 * position above the anchor edge
+	 */
+	ZXDG_POSITIONER_V6_GRAVITY_TOP = 1,
+	/**
+	 * position below the anchor edge
+	 */
+	ZXDG_POSITIONER_V6_GRAVITY_BOTTOM = 2,
+	/**
+	 * position to the left of the anchor edge
+	 */
+	ZXDG_POSITIONER_V6_GRAVITY_LEFT = 4,
+	/**
+	 * position to the right of the anchor edge
+	 */
+	ZXDG_POSITIONER_V6_GRAVITY_RIGHT = 8,
+};
+#endif /* ZXDG_POSITIONER_V6_GRAVITY_ENUM */
+
+#ifndef ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_ENUM
+#define ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_ENUM
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ * vertically resize the surface
+ *
+ * Resize the surface vertically so that it is completely unconstrained.
+ */
+enum zxdg_positioner_v6_constraint_adjustment {
+	ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_NONE = 0,
+	ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_SLIDE_X = 1,
+	ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_SLIDE_Y = 2,
+	ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_FLIP_X = 4,
+	ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_FLIP_Y = 8,
+	ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_RESIZE_X = 16,
+	ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_RESIZE_Y = 32,
+};
+#endif /* ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_ENUM */
+
+#define ZXDG_POSITIONER_V6_DESTROY 0
+#define ZXDG_POSITIONER_V6_SET_SIZE 1
+#define ZXDG_POSITIONER_V6_SET_ANCHOR_RECT 2
+#define ZXDG_POSITIONER_V6_SET_ANCHOR 3
+#define ZXDG_POSITIONER_V6_SET_GRAVITY 4
+#define ZXDG_POSITIONER_V6_SET_CONSTRAINT_ADJUSTMENT 5
+#define ZXDG_POSITIONER_V6_SET_OFFSET 6
+
+
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ */
+#define ZXDG_POSITIONER_V6_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ */
+#define ZXDG_POSITIONER_V6_SET_SIZE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ */
+#define ZXDG_POSITIONER_V6_SET_ANCHOR_RECT_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ */
+#define ZXDG_POSITIONER_V6_SET_ANCHOR_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ */
+#define ZXDG_POSITIONER_V6_SET_GRAVITY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ */
+#define ZXDG_POSITIONER_V6_SET_CONSTRAINT_ADJUSTMENT_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ */
+#define ZXDG_POSITIONER_V6_SET_OFFSET_SINCE_VERSION 1
+
+/** @ingroup iface_zxdg_positioner_v6 */
+static inline void
+zxdg_positioner_v6_set_user_data(struct zxdg_positioner_v6 *zxdg_positioner_v6, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zxdg_positioner_v6, user_data);
+}
+
+/** @ingroup iface_zxdg_positioner_v6 */
+static inline void *
+zxdg_positioner_v6_get_user_data(struct zxdg_positioner_v6 *zxdg_positioner_v6)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_positioner_v6);
+}
+
+static inline uint32_t
+zxdg_positioner_v6_get_version(struct zxdg_positioner_v6 *zxdg_positioner_v6)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zxdg_positioner_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ *
+ * Notify the compositor that the xdg_positioner will no longer be used.
+ */
+static inline void
+zxdg_positioner_v6_destroy(struct zxdg_positioner_v6 *zxdg_positioner_v6)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_positioner_v6,
+			 ZXDG_POSITIONER_V6_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zxdg_positioner_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ *
+ * Set the size of the surface that is to be positioned with the positioner
+ * object. The size is in surface-local coordinates and corresponds to the
+ * window geometry. See xdg_surface.set_window_geometry.
+ *
+ * If a zero or negative size is set the invalid_input error is raised.
+ */
+static inline void
+zxdg_positioner_v6_set_size(struct zxdg_positioner_v6 *zxdg_positioner_v6, int32_t width, int32_t height)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_positioner_v6,
+			 ZXDG_POSITIONER_V6_SET_SIZE, width, height);
+}
+
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ *
+ * Specify the anchor rectangle within the parent surface that the child
+ * surface will be placed relative to. The rectangle is relative to the
+ * window geometry as defined by xdg_surface.set_window_geometry of the
+ * parent surface. The rectangle must be at least 1x1 large.
+ *
+ * When the xdg_positioner object is used to position a child surface, the
+ * anchor rectangle may not extend outside the window geometry of the
+ * positioned child's parent surface.
+ *
+ * If a zero or negative size is set the invalid_input error is raised.
+ */
+static inline void
+zxdg_positioner_v6_set_anchor_rect(struct zxdg_positioner_v6 *zxdg_positioner_v6, int32_t x, int32_t y, int32_t width, int32_t height)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_positioner_v6,
+			 ZXDG_POSITIONER_V6_SET_ANCHOR_RECT, x, y, width, height);
+}
+
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ *
+ * Defines a set of edges for the anchor rectangle. These are used to
+ * derive an anchor point that the child surface will be positioned
+ * relative to. If two orthogonal edges are specified (e.g. 'top' and
+ * 'left'), then the anchor point will be the intersection of the edges
+ * (e.g. the top left position of the rectangle); otherwise, the derived
+ * anchor point will be centered on the specified edge, or in the center of
+ * the anchor rectangle if no edge is specified.
+ *
+ * If two parallel anchor edges are specified (e.g. 'left' and 'right'),
+ * the invalid_input error is raised.
+ */
+static inline void
+zxdg_positioner_v6_set_anchor(struct zxdg_positioner_v6 *zxdg_positioner_v6, uint32_t anchor)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_positioner_v6,
+			 ZXDG_POSITIONER_V6_SET_ANCHOR, anchor);
+}
+
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ *
+ * Defines in what direction a surface should be positioned, relative to
+ * the anchor point of the parent surface. If two orthogonal gravities are
+ * specified (e.g. 'bottom' and 'right'), then the child surface will be
+ * placed in the specified direction; otherwise, the child surface will be
+ * centered over the anchor point on any axis that had no gravity
+ * specified.
+ *
+ * If two parallel gravities are specified (e.g. 'left' and 'right'), the
+ * invalid_input error is raised.
+ */
+static inline void
+zxdg_positioner_v6_set_gravity(struct zxdg_positioner_v6 *zxdg_positioner_v6, uint32_t gravity)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_positioner_v6,
+			 ZXDG_POSITIONER_V6_SET_GRAVITY, gravity);
+}
+
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ *
+ * Specify how the window should be positioned if the originally intended
+ * position caused the surface to be constrained, meaning at least
+ * partially outside positioning boundaries set by the compositor. The
+ * adjustment is set by constructing a bitmask describing the adjustment to
+ * be made when the surface is constrained on that axis.
+ *
+ * If no bit for one axis is set, the compositor will assume that the child
+ * surface should not change its position on that axis when constrained.
+ *
+ * If more than one bit for one axis is set, the order of how adjustments
+ * are applied is specified in the corresponding adjustment descriptions.
+ *
+ * The default adjustment is none.
+ */
+static inline void
+zxdg_positioner_v6_set_constraint_adjustment(struct zxdg_positioner_v6 *zxdg_positioner_v6, uint32_t constraint_adjustment)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_positioner_v6,
+			 ZXDG_POSITIONER_V6_SET_CONSTRAINT_ADJUSTMENT, constraint_adjustment);
+}
+
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ *
+ * Specify the surface position offset relative to the position of the
+ * anchor on the anchor rectangle and the anchor on the surface. For
+ * example if the anchor of the anchor rectangle is at (x, y), the surface
+ * has the gravity bottom|right, and the offset is (ox, oy), the calculated
+ * surface position will be (x + ox, y + oy). The offset position of the
+ * surface is the one used for constraint testing. See
+ * set_constraint_adjustment.
+ *
+ * An example use case is placing a popup menu on top of a user interface
+ * element, while aligning the user interface element of the parent surface
+ * with some user interface element placed somewhere in the popup surface.
+ */
+static inline void
+zxdg_positioner_v6_set_offset(struct zxdg_positioner_v6 *zxdg_positioner_v6, int32_t x, int32_t y)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_positioner_v6,
+			 ZXDG_POSITIONER_V6_SET_OFFSET, x, y);
+}
+
+#ifndef ZXDG_SURFACE_V6_ERROR_ENUM
+#define ZXDG_SURFACE_V6_ERROR_ENUM
+enum zxdg_surface_v6_error {
+	ZXDG_SURFACE_V6_ERROR_NOT_CONSTRUCTED = 1,
+	ZXDG_SURFACE_V6_ERROR_ALREADY_CONSTRUCTED = 2,
+	ZXDG_SURFACE_V6_ERROR_UNCONFIGURED_BUFFER = 3,
+};
+#endif /* ZXDG_SURFACE_V6_ERROR_ENUM */
+
+/**
+ * @ingroup iface_zxdg_surface_v6
+ * @struct zxdg_surface_v6_listener
+ */
+struct zxdg_surface_v6_listener {
+	/**
+	 * suggest a surface change
+	 *
+	 * The configure event marks the end of a configure sequence. A
+	 * configure sequence is a set of one or more events configuring
+	 * the state of the xdg_surface, including the final
+	 * xdg_surface.configure event.
+	 *
+	 * Where applicable, xdg_surface surface roles will during a
+	 * configure sequence extend this event as a latched state sent as
+	 * events before the xdg_surface.configure event. Such events
+	 * should be considered to make up a set of atomically applied
+	 * configuration states, where the xdg_surface.configure commits
+	 * the accumulated state.
+	 *
+	 * Clients should arrange their surface for the new states, and
+	 * then send an ack_configure request with the serial sent in this
+	 * configure event at some point before committing the new surface.
+	 *
+	 * If the client receives multiple configure events before it can
+	 * respond to one, it is free to discard all but the last event it
+	 * received.
+	 * @param serial serial of the configure event
+	 */
+	void (*configure)(void *data,
+			  struct zxdg_surface_v6 *zxdg_surface_v6,
+			  uint32_t serial);
+};
+
+/**
+ * @ingroup iface_zxdg_surface_v6
+ */
+static inline int
+zxdg_surface_v6_add_listener(struct zxdg_surface_v6 *zxdg_surface_v6,
+			     const struct zxdg_surface_v6_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zxdg_surface_v6,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZXDG_SURFACE_V6_DESTROY 0
+#define ZXDG_SURFACE_V6_GET_TOPLEVEL 1
+#define ZXDG_SURFACE_V6_GET_POPUP 2
+#define ZXDG_SURFACE_V6_SET_WINDOW_GEOMETRY 3
+#define ZXDG_SURFACE_V6_ACK_CONFIGURE 4
+
+/**
+ * @ingroup iface_zxdg_surface_v6
+ */
+#define ZXDG_SURFACE_V6_CONFIGURE_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zxdg_surface_v6
+ */
+#define ZXDG_SURFACE_V6_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_surface_v6
+ */
+#define ZXDG_SURFACE_V6_GET_TOPLEVEL_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_surface_v6
+ */
+#define ZXDG_SURFACE_V6_GET_POPUP_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_surface_v6
+ */
+#define ZXDG_SURFACE_V6_SET_WINDOW_GEOMETRY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_surface_v6
+ */
+#define ZXDG_SURFACE_V6_ACK_CONFIGURE_SINCE_VERSION 1
+
+/** @ingroup iface_zxdg_surface_v6 */
+static inline void
+zxdg_surface_v6_set_user_data(struct zxdg_surface_v6 *zxdg_surface_v6, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zxdg_surface_v6, user_data);
+}
+
+/** @ingroup iface_zxdg_surface_v6 */
+static inline void *
+zxdg_surface_v6_get_user_data(struct zxdg_surface_v6 *zxdg_surface_v6)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_surface_v6);
+}
+
+static inline uint32_t
+zxdg_surface_v6_get_version(struct zxdg_surface_v6 *zxdg_surface_v6)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zxdg_surface_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_surface_v6
+ *
+ * Destroy the xdg_surface object. An xdg_surface must only be destroyed
+ * after its role object has been destroyed.
+ */
+static inline void
+zxdg_surface_v6_destroy(struct zxdg_surface_v6 *zxdg_surface_v6)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_surface_v6,
+			 ZXDG_SURFACE_V6_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zxdg_surface_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_surface_v6
+ *
+ * This creates an xdg_toplevel object for the given xdg_surface and gives
+ * the associated wl_surface the xdg_toplevel role.
+ *
+ * See the documentation of xdg_toplevel for more details about what an
+ * xdg_toplevel is and how it is used.
+ */
+static inline struct zxdg_toplevel_v6 *
+zxdg_surface_v6_get_toplevel(struct zxdg_surface_v6 *zxdg_surface_v6)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) zxdg_surface_v6,
+			 ZXDG_SURFACE_V6_GET_TOPLEVEL, &zxdg_toplevel_v6_interface, NULL);
+
+	return (struct zxdg_toplevel_v6 *) id;
+}
+
+/**
+ * @ingroup iface_zxdg_surface_v6
+ *
+ * This creates an xdg_popup object for the given xdg_surface and gives the
+ * associated wl_surface the xdg_popup role.
+ *
+ * See the documentation of xdg_popup for more details about what an
+ * xdg_popup is and how it is used.
+ */
+static inline struct zxdg_popup_v6 *
+zxdg_surface_v6_get_popup(struct zxdg_surface_v6 *zxdg_surface_v6, struct zxdg_surface_v6 *parent, struct zxdg_positioner_v6 *positioner)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) zxdg_surface_v6,
+			 ZXDG_SURFACE_V6_GET_POPUP, &zxdg_popup_v6_interface, NULL, parent, positioner);
+
+	return (struct zxdg_popup_v6 *) id;
+}
+
+/**
+ * @ingroup iface_zxdg_surface_v6
+ *
+ * The window geometry of a surface is its "visible bounds" from the
+ * user's perspective. Client-side decorations often have invisible
+ * portions like drop-shadows which should be ignored for the
+ * purposes of aligning, placing and constraining windows.
+ *
+ * The window geometry is double buffered, and will be applied at the
+ * time wl_surface.commit of the corresponding wl_surface is called.
+ *
+ * Once the window geometry of the surface is set, it is not possible to
+ * unset it, and it will remain the same until set_window_geometry is
+ * called again, even if a new subsurface or buffer is attached.
+ *
+ * If never set, the value is the full bounds of the surface,
+ * including any subsurfaces. This updates dynamically on every
+ * commit. This unset is meant for extremely simple clients.
+ *
+ * The arguments are given in the surface-local coordinate space of
+ * the wl_surface associated with this xdg_surface.
+ *
+ * The width and height must be greater than zero. Setting an invalid size
+ * will raise an error. When applied, the effective window geometry will be
+ * the set window geometry clamped to the bounding rectangle of the
+ * combined geometry of the surface of the xdg_surface and the associated
+ * subsurfaces.
+ */
+static inline void
+zxdg_surface_v6_set_window_geometry(struct zxdg_surface_v6 *zxdg_surface_v6, int32_t x, int32_t y, int32_t width, int32_t height)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_surface_v6,
+			 ZXDG_SURFACE_V6_SET_WINDOW_GEOMETRY, x, y, width, height);
+}
+
+/**
+ * @ingroup iface_zxdg_surface_v6
+ *
+ * When a configure event is received, if a client commits the
+ * surface in response to the configure event, then the client
+ * must make an ack_configure request sometime before the commit
+ * request, passing along the serial of the configure event.
+ *
+ * For instance, for toplevel surfaces the compositor might use this
+ * information to move a surface to the top left only when the client has
+ * drawn itself for the maximized or fullscreen state.
+ *
+ * If the client receives multiple configure events before it
+ * can respond to one, it only has to ack the last configure event.
+ *
+ * A client is not required to commit immediately after sending
+ * an ack_configure request - it may even ack_configure several times
+ * before its next surface commit.
+ *
+ * A client may send multiple ack_configure requests before committing, but
+ * only the last request sent before a commit indicates which configure
+ * event the client really is responding to.
+ */
+static inline void
+zxdg_surface_v6_ack_configure(struct zxdg_surface_v6 *zxdg_surface_v6, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_surface_v6,
+			 ZXDG_SURFACE_V6_ACK_CONFIGURE, serial);
+}
+
+#ifndef ZXDG_TOPLEVEL_V6_RESIZE_EDGE_ENUM
+#define ZXDG_TOPLEVEL_V6_RESIZE_EDGE_ENUM
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ * edge values for resizing
+ *
+ * These values are used to indicate which edge of a surface
+ * is being dragged in a resize operation.
+ */
+enum zxdg_toplevel_v6_resize_edge {
+	ZXDG_TOPLEVEL_V6_RESIZE_EDGE_NONE = 0,
+	ZXDG_TOPLEVEL_V6_RESIZE_EDGE_TOP = 1,
+	ZXDG_TOPLEVEL_V6_RESIZE_EDGE_BOTTOM = 2,
+	ZXDG_TOPLEVEL_V6_RESIZE_EDGE_LEFT = 4,
+	ZXDG_TOPLEVEL_V6_RESIZE_EDGE_TOP_LEFT = 5,
+	ZXDG_TOPLEVEL_V6_RESIZE_EDGE_BOTTOM_LEFT = 6,
+	ZXDG_TOPLEVEL_V6_RESIZE_EDGE_RIGHT = 8,
+	ZXDG_TOPLEVEL_V6_RESIZE_EDGE_TOP_RIGHT = 9,
+	ZXDG_TOPLEVEL_V6_RESIZE_EDGE_BOTTOM_RIGHT = 10,
+};
+#endif /* ZXDG_TOPLEVEL_V6_RESIZE_EDGE_ENUM */
+
+#ifndef ZXDG_TOPLEVEL_V6_STATE_ENUM
+#define ZXDG_TOPLEVEL_V6_STATE_ENUM
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ * the surface is now activated
+ *
+ * Client window decorations should be painted as if the window is
+ * active. Do not assume this means that the window actually has
+ * keyboard or pointer focus.
+ */
+enum zxdg_toplevel_v6_state {
+	/**
+	 * the surface is maximized
+	 */
+	ZXDG_TOPLEVEL_V6_STATE_MAXIMIZED = 1,
+	/**
+	 * the surface is fullscreen
+	 */
+	ZXDG_TOPLEVEL_V6_STATE_FULLSCREEN = 2,
+	/**
+	 * the surface is being resized
+	 */
+	ZXDG_TOPLEVEL_V6_STATE_RESIZING = 3,
+	/**
+	 * the surface is now activated
+	 */
+	ZXDG_TOPLEVEL_V6_STATE_ACTIVATED = 4,
+};
+#endif /* ZXDG_TOPLEVEL_V6_STATE_ENUM */
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ * @struct zxdg_toplevel_v6_listener
+ */
+struct zxdg_toplevel_v6_listener {
+	/**
+	 * suggest a surface change
+	 *
+	 * This configure event asks the client to resize its toplevel
+	 * surface or to change its state. The configured state should not
+	 * be applied immediately. See xdg_surface.configure for details.
+	 *
+	 * The width and height arguments specify a hint to the window
+	 * about how its surface should be resized in window geometry
+	 * coordinates. See set_window_geometry.
+	 *
+	 * If the width or height arguments are zero, it means the client
+	 * should decide its own window dimension. This may happen when the
+	 * compositor need to configure the state of the surface but
+	 * doesn't have any information about any previous or expected
+	 * dimension.
+	 *
+	 * The states listed in the event specify how the width/height
+	 * arguments should be interpreted, and possibly how it should be
+	 * drawn.
+	 *
+	 * Clients must send an ack_configure in response to this event.
+	 * See xdg_surface.configure and xdg_surface.ack_configure for
+	 * details.
+	 */
+	void (*configure)(void *data,
+			  struct zxdg_toplevel_v6 *zxdg_toplevel_v6,
+			  int32_t width,
+			  int32_t height,
+			  struct wl_array *states);
+	/**
+	 * surface wants to be closed
+	 *
+	 * The close event is sent by the compositor when the user wants
+	 * the surface to be closed. This should be equivalent to the user
+	 * clicking the close button in client-side decorations, if your
+	 * application has any...
+	 *
+	 * This is only a request that the user intends to close your
+	 * window. The client may choose to ignore this request, or show a
+	 * dialog to ask the user to save their data...
+	 */
+	void (*close)(void *data,
+		      struct zxdg_toplevel_v6 *zxdg_toplevel_v6);
+};
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+static inline int
+zxdg_toplevel_v6_add_listener(struct zxdg_toplevel_v6 *zxdg_toplevel_v6,
+			      const struct zxdg_toplevel_v6_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zxdg_toplevel_v6,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZXDG_TOPLEVEL_V6_DESTROY 0
+#define ZXDG_TOPLEVEL_V6_SET_PARENT 1
+#define ZXDG_TOPLEVEL_V6_SET_TITLE 2
+#define ZXDG_TOPLEVEL_V6_SET_APP_ID 3
+#define ZXDG_TOPLEVEL_V6_SHOW_WINDOW_MENU 4
+#define ZXDG_TOPLEVEL_V6_MOVE 5
+#define ZXDG_TOPLEVEL_V6_RESIZE 6
+#define ZXDG_TOPLEVEL_V6_SET_MAX_SIZE 7
+#define ZXDG_TOPLEVEL_V6_SET_MIN_SIZE 8
+#define ZXDG_TOPLEVEL_V6_SET_MAXIMIZED 9
+#define ZXDG_TOPLEVEL_V6_UNSET_MAXIMIZED 10
+#define ZXDG_TOPLEVEL_V6_SET_FULLSCREEN 11
+#define ZXDG_TOPLEVEL_V6_UNSET_FULLSCREEN 12
+#define ZXDG_TOPLEVEL_V6_SET_MINIMIZED 13
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_CONFIGURE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_CLOSE_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_SET_PARENT_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_SET_TITLE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_SET_APP_ID_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_SHOW_WINDOW_MENU_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_MOVE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_RESIZE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_SET_MAX_SIZE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_SET_MIN_SIZE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_SET_MAXIMIZED_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_UNSET_MAXIMIZED_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_SET_FULLSCREEN_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_UNSET_FULLSCREEN_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_SET_MINIMIZED_SINCE_VERSION 1
+
+/** @ingroup iface_zxdg_toplevel_v6 */
+static inline void
+zxdg_toplevel_v6_set_user_data(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zxdg_toplevel_v6, user_data);
+}
+
+/** @ingroup iface_zxdg_toplevel_v6 */
+static inline void *
+zxdg_toplevel_v6_get_user_data(struct zxdg_toplevel_v6 *zxdg_toplevel_v6)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_toplevel_v6);
+}
+
+static inline uint32_t
+zxdg_toplevel_v6_get_version(struct zxdg_toplevel_v6 *zxdg_toplevel_v6)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zxdg_toplevel_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Unmap and destroy the window. The window will be effectively
+ * hidden from the user's point of view, and all state like
+ * maximization, fullscreen, and so on, will be lost.
+ */
+static inline void
+zxdg_toplevel_v6_destroy(struct zxdg_toplevel_v6 *zxdg_toplevel_v6)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zxdg_toplevel_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Set the "parent" of this surface. This window should be stacked
+ * above a parent. The parent surface must be mapped as long as this
+ * surface is mapped.
+ *
+ * Parent windows should be set on dialogs, toolboxes, or other
+ * "auxiliary" surfaces, so that the parent is raised when the dialog
+ * is raised.
+ */
+static inline void
+zxdg_toplevel_v6_set_parent(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, struct zxdg_toplevel_v6 *parent)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_SET_PARENT, parent);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Set a short title for the surface.
+ *
+ * This string may be used to identify the surface in a task bar,
+ * window list, or other user interface elements provided by the
+ * compositor.
+ *
+ * The string must be encoded in UTF-8.
+ */
+static inline void
+zxdg_toplevel_v6_set_title(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, const char *title)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_SET_TITLE, title);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Set an application identifier for the surface.
+ *
+ * The app ID identifies the general class of applications to which
+ * the surface belongs. The compositor can use this to group multiple
+ * surfaces together, or to determine how to launch a new application.
+ *
+ * For D-Bus activatable applications, the app ID is used as the D-Bus
+ * service name.
+ *
+ * The compositor shell will try to group application surfaces together
+ * by their app ID.  As a best practice, it is suggested to select app
+ * ID's that match the basename of the application's .desktop file.
+ * For example, "org.freedesktop.FooViewer" where the .desktop file is
+ * "org.freedesktop.FooViewer.desktop".
+ *
+ * See the desktop-entry specification [0] for more details on
+ * application identifiers and how they relate to well-known D-Bus
+ * names and .desktop files.
+ *
+ * [0] http://standards.freedesktop.org/desktop-entry-spec/
+ */
+static inline void
+zxdg_toplevel_v6_set_app_id(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, const char *app_id)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_SET_APP_ID, app_id);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Clients implementing client-side decorations might want to show
+ * a context menu when right-clicking on the decorations, giving the
+ * user a menu that they can use to maximize or minimize the window.
+ *
+ * This request asks the compositor to pop up such a window menu at
+ * the given position, relative to the local surface coordinates of
+ * the parent surface. There are no guarantees as to what menu items
+ * the window menu contains.
+ *
+ * This request must be used in response to some sort of user action
+ * like a button press, key press, or touch down event.
+ */
+static inline void
+zxdg_toplevel_v6_show_window_menu(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, struct wl_seat *seat, uint32_t serial, int32_t x, int32_t y)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_SHOW_WINDOW_MENU, seat, serial, x, y);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Start an interactive, user-driven move of the surface.
+ *
+ * This request must be used in response to some sort of user action
+ * like a button press, key press, or touch down event. The passed
+ * serial is used to determine the type of interactive move (touch,
+ * pointer, etc).
+ *
+ * The server may ignore move requests depending on the state of
+ * the surface (e.g. fullscreen or maximized), or if the passed serial
+ * is no longer valid.
+ *
+ * If triggered, the surface will lose the focus of the device
+ * (wl_pointer, wl_touch, etc) used for the move. It is up to the
+ * compositor to visually indicate that the move is taking place, such as
+ * updating a pointer cursor, during the move. There is no guarantee
+ * that the device focus will return when the move is completed.
+ */
+static inline void
+zxdg_toplevel_v6_move(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, struct wl_seat *seat, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_MOVE, seat, serial);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Start a user-driven, interactive resize of the surface.
+ *
+ * This request must be used in response to some sort of user action
+ * like a button press, key press, or touch down event. The passed
+ * serial is used to determine the type of interactive resize (touch,
+ * pointer, etc).
+ *
+ * The server may ignore resize requests depending on the state of
+ * the surface (e.g. fullscreen or maximized).
+ *
+ * If triggered, the client will receive configure events with the
+ * "resize" state enum value and the expected sizes. See the "resize"
+ * enum value for more details about what is required. The client
+ * must also acknowledge configure events using "ack_configure". After
+ * the resize is completed, the client will receive another "configure"
+ * event without the resize state.
+ *
+ * If triggered, the surface also will lose the focus of the device
+ * (wl_pointer, wl_touch, etc) used for the resize. It is up to the
+ * compositor to visually indicate that the resize is taking place,
+ * such as updating a pointer cursor, during the resize. There is no
+ * guarantee that the device focus will return when the resize is
+ * completed.
+ *
+ * The edges parameter specifies how the surface should be resized,
+ * and is one of the values of the resize_edge enum. The compositor
+ * may use this information to update the surface position for
+ * example when dragging the top left corner. The compositor may also
+ * use this information to adapt its behavior, e.g. choose an
+ * appropriate cursor image.
+ */
+static inline void
+zxdg_toplevel_v6_resize(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, struct wl_seat *seat, uint32_t serial, uint32_t edges)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_RESIZE, seat, serial, edges);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Set a maximum size for the window.
+ *
+ * The client can specify a maximum size so that the compositor does
+ * not try to configure the window beyond this size.
+ *
+ * The width and height arguments are in window geometry coordinates.
+ * See xdg_surface.set_window_geometry.
+ *
+ * Values set in this way are double-buffered. They will get applied
+ * on the next commit.
+ *
+ * The compositor can use this information to allow or disallow
+ * different states like maximize or fullscreen and draw accurate
+ * animations.
+ *
+ * Similarly, a tiling window manager may use this information to
+ * place and resize client windows in a more effective way.
+ *
+ * The client should not rely on the compositor to obey the maximum
+ * size. The compositor may decide to ignore the values set by the
+ * client and request a larger size.
+ *
+ * If never set, or a value of zero in the request, means that the
+ * client has no expected maximum size in the given dimension.
+ * As a result, a client wishing to reset the maximum size
+ * to an unspecified state can use zero for width and height in the
+ * request.
+ *
+ * Requesting a maximum size to be smaller than the minimum size of
+ * a surface is illegal and will result in a protocol error.
+ *
+ * The width and height must be greater than or equal to zero. Using
+ * strictly negative values for width and height will result in a
+ * protocol error.
+ */
+static inline void
+zxdg_toplevel_v6_set_max_size(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, int32_t width, int32_t height)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_SET_MAX_SIZE, width, height);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Set a minimum size for the window.
+ *
+ * The client can specify a minimum size so that the compositor does
+ * not try to configure the window below this size.
+ *
+ * The width and height arguments are in window geometry coordinates.
+ * See xdg_surface.set_window_geometry.
+ *
+ * Values set in this way are double-buffered. They will get applied
+ * on the next commit.
+ *
+ * The compositor can use this information to allow or disallow
+ * different states like maximize or fullscreen and draw accurate
+ * animations.
+ *
+ * Similarly, a tiling window manager may use this information to
+ * place and resize client windows in a more effective way.
+ *
+ * The client should not rely on the compositor to obey the minimum
+ * size. The compositor may decide to ignore the values set by the
+ * client and request a smaller size.
+ *
+ * If never set, or a value of zero in the request, means that the
+ * client has no expected minimum size in the given dimension.
+ * As a result, a client wishing to reset the minimum size
+ * to an unspecified state can use zero for width and height in the
+ * request.
+ *
+ * Requesting a minimum size to be larger than the maximum size of
+ * a surface is illegal and will result in a protocol error.
+ *
+ * The width and height must be greater than or equal to zero. Using
+ * strictly negative values for width and height will result in a
+ * protocol error.
+ */
+static inline void
+zxdg_toplevel_v6_set_min_size(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, int32_t width, int32_t height)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_SET_MIN_SIZE, width, height);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Maximize the surface.
+ *
+ * After requesting that the surface should be maximized, the compositor
+ * will respond by emitting a configure event with the "maximized" state
+ * and the required window geometry. The client should then update its
+ * content, drawing it in a maximized state, i.e. without shadow or other
+ * decoration outside of the window geometry. The client must also
+ * acknowledge the configure when committing the new content (see
+ * ack_configure).
+ *
+ * It is up to the compositor to decide how and where to maximize the
+ * surface, for example which output and what region of the screen should
+ * be used.
+ *
+ * If the surface was already maximized, the compositor will still emit
+ * a configure event with the "maximized" state.
+ */
+static inline void
+zxdg_toplevel_v6_set_maximized(struct zxdg_toplevel_v6 *zxdg_toplevel_v6)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_SET_MAXIMIZED);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Unmaximize the surface.
+ *
+ * After requesting that the surface should be unmaximized, the compositor
+ * will respond by emitting a configure event without the "maximized"
+ * state. If available, the compositor will include the window geometry
+ * dimensions the window had prior to being maximized in the configure
+ * request. The client must then update its content, drawing it in a
+ * regular state, i.e. potentially with shadow, etc. The client must also
+ * acknowledge the configure when committing the new content (see
+ * ack_configure).
+ *
+ * It is up to the compositor to position the surface after it was
+ * unmaximized; usually the position the surface had before maximizing, if
+ * applicable.
+ *
+ * If the surface was already not maximized, the compositor will still
+ * emit a configure event without the "maximized" state.
+ */
+static inline void
+zxdg_toplevel_v6_unset_maximized(struct zxdg_toplevel_v6 *zxdg_toplevel_v6)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_UNSET_MAXIMIZED);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Make the surface fullscreen.
+ *
+ * You can specify an output that you would prefer to be fullscreen.
+ * If this value is NULL, it's up to the compositor to choose which
+ * display will be used to map this surface.
+ *
+ * If the surface doesn't cover the whole output, the compositor will
+ * position the surface in the center of the output and compensate with
+ * black borders filling the rest of the output.
+ */
+static inline void
+zxdg_toplevel_v6_set_fullscreen(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, struct wl_output *output)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_SET_FULLSCREEN, output);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+static inline void
+zxdg_toplevel_v6_unset_fullscreen(struct zxdg_toplevel_v6 *zxdg_toplevel_v6)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_UNSET_FULLSCREEN);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Request that the compositor minimize your surface. There is no
+ * way to know if the surface is currently minimized, nor is there
+ * any way to unset minimization on this surface.
+ *
+ * If you are looking to throttle redrawing when minimized, please
+ * instead use the wl_surface.frame event for this, as this will
+ * also work with live previews on windows in Alt-Tab, Expose or
+ * similar compositor features.
+ */
+static inline void
+zxdg_toplevel_v6_set_minimized(struct zxdg_toplevel_v6 *zxdg_toplevel_v6)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_SET_MINIMIZED);
+}
+
+#ifndef ZXDG_POPUP_V6_ERROR_ENUM
+#define ZXDG_POPUP_V6_ERROR_ENUM
+enum zxdg_popup_v6_error {
+	/**
+	 * tried to grab after being mapped
+	 */
+	ZXDG_POPUP_V6_ERROR_INVALID_GRAB = 0,
+};
+#endif /* ZXDG_POPUP_V6_ERROR_ENUM */
+
+/**
+ * @ingroup iface_zxdg_popup_v6
+ * @struct zxdg_popup_v6_listener
+ */
+struct zxdg_popup_v6_listener {
+	/**
+	 * configure the popup surface
+	 *
+	 * This event asks the popup surface to configure itself given
+	 * the configuration. The configured state should not be applied
+	 * immediately. See xdg_surface.configure for details.
+	 *
+	 * The x and y arguments represent the position the popup was
+	 * placed at given the xdg_positioner rule, relative to the upper
+	 * left corner of the window geometry of the parent surface.
+	 * @param x x position relative to parent surface window geometry
+	 * @param y y position relative to parent surface window geometry
+	 * @param width window geometry width
+	 * @param height window geometry height
+	 */
+	void (*configure)(void *data,
+			  struct zxdg_popup_v6 *zxdg_popup_v6,
+			  int32_t x,
+			  int32_t y,
+			  int32_t width,
+			  int32_t height);
+	/**
+	 * popup interaction is done
+	 *
+	 * The popup_done event is sent out when a popup is dismissed by
+	 * the compositor. The client should destroy the xdg_popup object
+	 * at this point.
+	 */
+	void (*popup_done)(void *data,
+			   struct zxdg_popup_v6 *zxdg_popup_v6);
+};
+
+/**
+ * @ingroup iface_zxdg_popup_v6
+ */
+static inline int
+zxdg_popup_v6_add_listener(struct zxdg_popup_v6 *zxdg_popup_v6,
+			   const struct zxdg_popup_v6_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zxdg_popup_v6,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZXDG_POPUP_V6_DESTROY 0
+#define ZXDG_POPUP_V6_GRAB 1
+
+/**
+ * @ingroup iface_zxdg_popup_v6
+ */
+#define ZXDG_POPUP_V6_CONFIGURE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_popup_v6
+ */
+#define ZXDG_POPUP_V6_POPUP_DONE_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zxdg_popup_v6
+ */
+#define ZXDG_POPUP_V6_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_popup_v6
+ */
+#define ZXDG_POPUP_V6_GRAB_SINCE_VERSION 1
+
+/** @ingroup iface_zxdg_popup_v6 */
+static inline void
+zxdg_popup_v6_set_user_data(struct zxdg_popup_v6 *zxdg_popup_v6, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zxdg_popup_v6, user_data);
+}
+
+/** @ingroup iface_zxdg_popup_v6 */
+static inline void *
+zxdg_popup_v6_get_user_data(struct zxdg_popup_v6 *zxdg_popup_v6)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_popup_v6);
+}
+
+static inline uint32_t
+zxdg_popup_v6_get_version(struct zxdg_popup_v6 *zxdg_popup_v6)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zxdg_popup_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_popup_v6
+ *
+ * This destroys the popup. Explicitly destroying the xdg_popup
+ * object will also dismiss the popup, and unmap the surface.
+ *
+ * If this xdg_popup is not the "topmost" popup, a protocol error
+ * will be sent.
+ */
+static inline void
+zxdg_popup_v6_destroy(struct zxdg_popup_v6 *zxdg_popup_v6)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_popup_v6,
+			 ZXDG_POPUP_V6_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zxdg_popup_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_popup_v6
+ *
+ * This request makes the created popup take an explicit grab. An explicit
+ * grab will be dismissed when the user dismisses the popup, or when the
+ * client destroys the xdg_popup. This can be done by the user clicking
+ * outside the surface, using the keyboard, or even locking the screen
+ * through closing the lid or a timeout.
+ *
+ * If the compositor denies the grab, the popup will be immediately
+ * dismissed.
+ *
+ * This request must be used in response to some sort of user action like a
+ * button press, key press, or touch down event. The serial number of the
+ * event should be passed as 'serial'.
+ *
+ * The parent of a grabbing popup must either be an xdg_toplevel surface or
+ * another xdg_popup with an explicit grab. If the parent is another
+ * xdg_popup it means that the popups are nested, with this popup now being
+ * the topmost popup.
+ *
+ * Nested popups must be destroyed in the reverse order they were created
+ * in, e.g. the only popup you are allowed to destroy at all times is the
+ * topmost one.
+ *
+ * When compositors choose to dismiss a popup, they may dismiss every
+ * nested grabbing popup as well. When a compositor dismisses popups, it
+ * will follow the same dismissing order as required from the client.
+ *
+ * The parent of a grabbing popup must either be another xdg_popup with an
+ * active explicit grab, or an xdg_popup or xdg_toplevel, if there are no
+ * explicit grabs already taken.
+ *
+ * If the topmost grabbing popup is destroyed, the grab will be returned to
+ * the parent of the popup, if that parent previously had an explicit grab.
+ *
+ * If the parent is a grabbing popup which has already been dismissed, this
+ * popup will be immediately dismissed. If the parent is a popup that did
+ * not take an explicit grab, an error will be raised.
+ *
+ * During a popup grab, the client owning the grab will receive pointer
+ * and touch events for all their surfaces as normal (similar to an
+ * "owner-events" grab in X11 parlance), while the top most grabbing popup
+ * will always have keyboard focus.
+ */
+static inline void
+zxdg_popup_v6_grab(struct zxdg_popup_v6 *zxdg_popup_v6, struct wl_seat *seat, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_popup_v6,
+			 ZXDG_POPUP_V6_GRAB, seat, serial);
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
-- 
1.9.1

